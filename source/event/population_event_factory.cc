//////////////////////////////////////////////////////////////////////////////
// Copyright (C) 1993 - 2003 California Institute of Technology             //
//                                                                          //
// Read the COPYING and README files, or contact 'avida@alife.org',         //
// before continuing.  SOME RESTRICTIONS MAY APPLY TO USE OF THIS FILE.     //
//////////////////////////////////////////////////////////////////////////////

#ifndef POPULATION_EVENT_FACTORY_HH
#include "population_event_factory.hh"
#endif

#ifndef ANALYZE_UTIL_HH
#include "analyze_util.hh"
#endif
#ifndef AVIDA_HH
#include "avida.hh"
#endif
#ifndef AVIDA_DRIVER_BASE_HH
#include "avida_driver_base.hh"
#endif
#ifndef CONFIG_HH
#include "config.hh"
#endif
#ifndef ENVIRONMENT_HH
#include "environment.hh"
#endif
#ifndef EVENT_HH
#include "event.hh"
#endif
#ifndef GENEBANK_HH
#include "genebank.hh"
#endif
#ifndef GENOTYPE_HH
#include "genotype.hh"
#endif
#ifndef INJECT_GENEBANK_HH
#include "inject_genebank.hh"
#endif
#ifndef INJECT_GENOTYPE_HH
#include "inject_genotype.hh"
#endif
#ifndef INST_UTIL_HH
#include "inst_util.hh"
#endif
#ifndef LANDSCAPE_HH
#include "landscape.hh"
#endif
#ifndef LINEAGE_CONTROL_HH
#include "lineage_control.hh"
#endif
#ifndef ORGANISM_HH
#include "organism.hh"
#endif
#ifndef PHENOTYPE_HH
#include "phenotype.hh"
#endif
#ifndef POPULATION_HH
#include "population.hh"
#endif
#ifndef POPULATION_CELL_HH
#include "population_cell.hh"
#endif
#ifndef POPULATION_EVENT_HH
#include "population_event.hh"
#endif
#ifndef RESOURCE_HH
#include "resource.hh"
#endif
#ifndef STATS_HH
#include "stats.hh"
#endif
#ifndef STRING_UTIL_HH
#include "string_util.hh"
#endif
#ifndef TEST_CPU_HH
#include "test_cpu.hh"
#endif
#ifndef TEST_UTIL_HH
#include "test_util.hh"
#endif
#ifndef TOOLS_HH
#include "tools.hh"
#endif

#include <ctype.h>           // for isdigit

using namespace std;



/////////////////
//  events derived from cPopulationEvent (autogenerated code)
/////////////////

// The Process() functions
using namespace std;

///// exit /////

/**
* Ends the Avida run immediately.
 **/


class cPopulationEventexit : public cPopulationEvent {
private:
public:
  cPopulationEventexit(const cString & in_args):
  cPopulationEvent("exit", in_args) {
    (void)in_args; }
  ///// exit /////
  void Process(){
    cAvidaDriver_Base::main_driver->SetDone();
  }
};

///// exit_if_generation_greater_than /////

/**
* Ends the Avida run when the current generation exceeds the
 * maximum generation given as parameter.
 *
 * Parameters:
 * max generation (int)
 *   The generation at which the run should be stopped.
 **/


class cPopulationEventexit_if_generation_greater_than : public cPopulationEvent {
private:
  int max_generation;
public:
  cPopulationEventexit_if_generation_greater_than(const cString & in_args):
  cPopulationEvent("exit_if_generation_greater_than", in_args) {
    
    cString args(in_args);
    max_generation = args.PopWord().AsInt();
  }
  ///// exit_if_generation_greater_than /////
  void Process(){
    if( population->GetGeneration() > max_generation ){
      cAvidaDriver_Base::main_driver->SetDone();
    }
  }
};

///// exit_if_update_greater_than /////

/**
* Ends the Avida run when the current update exceeds the
 * maximum update given as parameter.
 *
 * Parameters:
 * max update (int)
 *   The update at which the run should be stopped.
 **/


class cPopulationEventexit_if_update_greater_than : public cPopulationEvent {
private:
  int max_update;
public:
  cPopulationEventexit_if_update_greater_than(const cString & in_args):
  cPopulationEvent("exit_if_update_greater_than", in_args) {
    
    cString args(in_args);
    max_update = args.PopWord().AsInt();
  }
  ///// exit_if_update_greater_than /////
  void Process(){
    if( population->GetUpdate() > max_update ){
      cAvidaDriver_Base::main_driver->SetDone();
    }
  }
};

///// exit_if_ave_lineage_label_smaller /////

/**
* Halts the avida run if the current average lineage label is smaller
 * than the value given as parameter.
 *
 * Parameters:
 * lineage_label_crit_value (int)
 *   The critical value to which the average lineage label is compared.
 **/


class cPopulationEventexit_if_ave_lineage_label_smaller : public cPopulationEvent {
private:
  double lineage_label_crit_value;
public:
  cPopulationEventexit_if_ave_lineage_label_smaller(const cString & in_args):
  cPopulationEvent("exit_if_ave_lineage_label_smaller", in_args) {
    
    cString args(in_args);
    lineage_label_crit_value = args.PopWord().AsDouble();
  }
  ///// exit_if_ave_lineage_label_smaller /////
  void Process(){
    if( population->GetStats().GetAveLineageLabel() < lineage_label_crit_value ){
      cAvidaDriver_Base::main_driver->SetDone();
    }
  }
};

///// exit_if_ave_lineage_label_larger /////

/**
* Halts the avida run if the current average lineage label is larger
 * than the value given as parameter.
 *
 * Parameters:
 * lineage_label_crit_value (int)
 *   The critical value to which the average lineage label is compared.
 **/


class cPopulationEventexit_if_ave_lineage_label_larger : public cPopulationEvent {
private:
  double lineage_label_crit_value;
public:
  cPopulationEventexit_if_ave_lineage_label_larger(const cString & in_args):
  cPopulationEvent("exit_if_ave_lineage_label_larger", in_args) {
    
    cString args(in_args);
    lineage_label_crit_value = args.PopWord().AsDouble();
  }
  ///// exit_if_ave_lineage_label_larger /////
  void Process(){
    if( population->GetStats().GetAveLineageLabel() > lineage_label_crit_value ){
      cAvidaDriver_Base::main_driver->SetDone();
    }
  }
};

///// echo /////

/**
* Writes out a message. If no message is given, average update and
 * generation are written out.
 *
 * Parameters:
 * message (string)
 **/


class cPopulationEventecho : public cPopulationEvent {
private:
  cString mesg;
public:
  cPopulationEventecho(const cString & in_args):
  cPopulationEvent("echo", in_args) {
    
    cString args(in_args);
    mesg = args.PopWord();
  }
  ///// echo /////
  void Process(){
    if( mesg == "" ){
      mesg.Set("Echo : Update = %f\t AveGeneration = %f",
               population->GetUpdate(), population->GetGeneration());
    }
    cAvidaDriver_Base::main_driver->NotifyComment(mesg);
  }
};

///// print_data /////

/**
* Output user-defined data from the cStats object...
 *
 * Parameters:
 * filename (string)
 *   The name of the data file.
 * format
 *   A comma-seperated list of statistics to output.
 **/


class cPopulationEventprint_data : public cPopulationEvent {
private:
  cString filename;
  cString format;
public:
    cPopulationEventprint_data(const cString & in_args):
    cPopulationEvent("print_data", in_args) {
      
      cString args(in_args);
      filename = args.PopWord();
      format = args.PopWord();
    }
  ///// print_data /////
  void Process(){
    population->GetStats().PrintDataFile(filename, format, ',');
  }
};

///// print_average_data /////

/**
* Output various average quantities into datafile.
 *
 * Parameters:
 * filename (string) default: average.dat
   *   The name of the data file.
   **/


class cPopulationEventprint_average_data : public cPopulationEvent {
private:
  cString fname;
public:
  cPopulationEventprint_average_data(const cString & in_args):
  cPopulationEvent("print_average_data", in_args) {
    
    cString args(in_args);
    if (args == "") fname="average.dat"; else fname=args.PopWord();
  }
  ///// print_average_data /////
  void Process(){
    population->GetStats().PrintAverageData(fname);
  }
};

///// print_error_data /////

/**
* Prints out various data related to statistical errors.
 *
 * Parameters:
 * filename (string) default: error.dat
   *   The name of the data file.
   **/


class cPopulationEventprint_error_data : public cPopulationEvent {
private:
  cString fname;
public:
  cPopulationEventprint_error_data(const cString & in_args):
  cPopulationEvent("print_error_data", in_args) {
    
    cString args(in_args);
    if (args == "") fname="error.dat"; else fname=args.PopWord();
  }
  ///// print_error_data /////
  void Process(){
    population->GetStats().PrintErrorData(fname);
  }
};

///// print_variance_data /////

/**
* Prints out various variances.
 *
 * Parameters:
 * filename (string) default: variance.dat
   *   The name of the data file.
   **/


class cPopulationEventprint_variance_data : public cPopulationEvent {
private:
  cString fname;
public:
  cPopulationEventprint_variance_data(const cString & in_args):
  cPopulationEvent("print_variance_data", in_args) {
    
    cString args(in_args);
    if (args == "") fname="variance.dat"; else fname=args.PopWord();
  }
  ///// print_variance_data /////
  void Process(){
    population->GetStats().PrintVarianceData(fname);
  }
};

///// print_dominant_data /////

/**
* Output various quantities related to the dominant organism.
 *
 * Parameters:
 * filename (string) default: dominant.dat
   *   The name of the data file.
   **/


class cPopulationEventprint_dominant_data : public cPopulationEvent {
private:
  cString fname;
public:
  cPopulationEventprint_dominant_data(const cString & in_args):
  cPopulationEvent("print_dominant_data", in_args) {
    
    cString args(in_args);
    if (args == "") fname="dominant.dat"; else fname=args.PopWord();
  }
  ///// print_dominant_data /////
  void Process(){
    population->GetStats().PrintDominantData(fname);
  }
};

///// print_stats_data /////

/**
* Output various statistical quantities.
 *
 * Parameters:
 * filename (string) default: stats.dat
   *   The name of the data file.
   **/


class cPopulationEventprint_stats_data : public cPopulationEvent {
private:
  cString fname;
public:
  cPopulationEventprint_stats_data(const cString & in_args):
  cPopulationEvent("print_stats_data", in_args) {
    
    cString args(in_args);
    if (args == "") fname="stats.dat"; else fname=args.PopWord();
  }
  ///// print_stats_data /////
  void Process(){
    population->GetStats().PrintStatsData(fname);
  }
};

///// print_count_data /////

/**
* Output various counts, such as number of organisms etc.
 *
 * Parameters:
 * filename (string) default: count.dat
   *   The name of the data file.
   **/


class cPopulationEventprint_count_data : public cPopulationEvent {
private:
  cString fname;
public:
  cPopulationEventprint_count_data(const cString & in_args):
  cPopulationEvent("print_count_data", in_args) {
    
    cString args(in_args);
    if (args == "") fname="count.dat"; else fname=args.PopWord();
  }
  ///// print_count_data /////
  void Process(){
    population->GetStats().PrintCountData(fname);
  }
};

///// print_totals_data /////

/**
* Various total numbers.
 *
 * Parameters:
 * filename (string) default: totals.dat
   *   The name of the data file.
   **/


class cPopulationEventprint_totals_data : public cPopulationEvent {
private:
  cString fname;
public:
  cPopulationEventprint_totals_data(const cString & in_args):
  cPopulationEvent("print_totals_data", in_args) {
    
    cString args(in_args);
    if (args == "") fname="totals.dat"; else fname=args.PopWord();
  }
  ///// print_totals_data /////
  void Process(){
    population->GetStats().PrintTotalsData(fname);
  }
};

///// print_tasks_data /////

/**
* Output the number of times the various tasks have been performed in the
 * last update.
 *
 * Parameters:
 * filename (string) default: tasks.dat
   *   The name of the data file.
   **/


class cPopulationEventprint_tasks_data : public cPopulationEvent {
private:
  cString fname;
public:
  cPopulationEventprint_tasks_data(const cString & in_args):
  cPopulationEvent("print_tasks_data", in_args) {
    
    cString args(in_args);
    if (args == "") fname="tasks.dat"; else fname=args.PopWord();
  }
  ///// print_tasks_data /////
  void Process(){
    population->GetStats().PrintTasksData(fname);
  }
};

///// print_tasks_exe_data /////

/**
**/


class cPopulationEventprint_tasks_exe_data : public cPopulationEvent {
private:
  cString fname;
public:
  cPopulationEventprint_tasks_exe_data(const cString & in_args):
  cPopulationEvent("print_tasks_exe_data", in_args) {
    
    cString args(in_args);
    if (args == "") fname="tasks_exe.dat"; else fname=args.PopWord();
  }
  ///// print_tasks_exe_data /////
  void Process(){
    population->GetStats().PrintTasksExeData(fname);
  }
};

///// print_resource_data /////

/**
**/


class cPopulationEventprint_resource_data : public cPopulationEvent {
private:
  cString fname;
public:
  cPopulationEventprint_resource_data(const cString & in_args):
  cPopulationEvent("print_resource_data", in_args) {
    
    cString args(in_args);
    if (args == "") fname="resource.dat"; else fname=args.PopWord();
  }
  ///// print_resource_data /////
  void Process(){
    population->GetStats().PrintResourceData(fname);
  }
};

///// print_time_data /////

/**
* Output time related data, such as update, generation, etc.
 *
 * Parameters:
 * filename (string) default: time.dat
   *   The name of the data file.
   **/


class cPopulationEventprint_time_data : public cPopulationEvent {
private:
  cString fname;
public:
  cPopulationEventprint_time_data(const cString & in_args):
  cPopulationEvent("print_time_data", in_args) {
    
    cString args(in_args);
    if (args == "") fname="time.dat"; else fname=args.PopWord();
  }
  ///// print_time_data /////
  void Process(){
    population->GetStats().PrintTimeData(fname);
  }
};

///// print_mutation_data /////

/**
**/


class cPopulationEventprint_mutation_data : public cPopulationEvent {
private:
  cString fname;
public:
  cPopulationEventprint_mutation_data(const cString & in_args):
  cPopulationEvent("print_mutation_data", in_args) {
    
    cString args(in_args);
    if (args == "") fname="mutation.dat"; else fname=args.PopWord();
  }
  ///// print_mutation_data /////
  void Process(){
    population->GetStats().PrintMutationData(fname);
  }
};

///// print_mutation_rate_data /////

/**
Output (regular and log) statistics about individual copy
 mutation rates (aver, stdev, skew, cur).
 Useful only when mutation rate is set per organism.
 **/


class cPopulationEventprint_mutation_rate_data : public cPopulationEvent {
private:
  cString fname;
public:
  cPopulationEventprint_mutation_rate_data(const cString & in_args):
  cPopulationEvent("print_mutation_rate_data", in_args) {
    
    cString args(in_args);
    if (args == "") fname="mutation_rates.dat"; else fname=args.PopWord();
  }
  ///// print_mutation_rate_data /////
  void Process(){
    population->GetStats().PrintMutationRateData(fname);
  }
};

///// print_divide_mut_data /////

/**
Output (regular and log) statistics about individual, per site,
 rates divide mutation rates (aver, stdev, skew, cur).
 Use with multiple divide instuction set.
 **/


class cPopulationEventprint_divide_mut_data : public cPopulationEvent {
private:
  cString fname;
public:
  cPopulationEventprint_divide_mut_data(const cString & in_args):
  cPopulationEvent("print_divide_mut_data", in_args) {
    
    cString args(in_args);
    if (args == "") fname="divide_mut.dat"; else fname=args.PopWord();
  }
  ///// print_divide_mut_data /////
  void Process(){
    population->GetStats().PrintDivideMutData(fname);
  }
};

///// print_dom_parasite_data /////

/**
* Output various quantities related to the dominant parasite.
 *
 * Parameters:
 * filename (string) default: parasite.dat
   *   The name of the data file.
   **/


class cPopulationEventprint_dom_parasite_data : public cPopulationEvent {
private:
  cString fname;
public:
  cPopulationEventprint_dom_parasite_data(const cString & in_args):
  cPopulationEvent("print_dom_parasite_data", in_args) {
    
    cString args(in_args);
    if (args == "") fname="parasite.dat"; else fname=args.PopWord();
  }
  ///// print_dom_parasite_data /////
  void Process(){
    population->GetStats().PrintDominantParaData(fname);
  }
};

///// print_instruction_data /////

/**
Sum of the by-organisms counts of what instructions they _successfully_
 execute beteween birth and divide. Prior to their first divide, organisms
 report values for their parents.
 **/


class cPopulationEventprint_instruction_data : public cPopulationEvent {
private:
  cString fname;
public:
  cPopulationEventprint_instruction_data(const cString & in_args):
  cPopulationEvent("print_instruction_data", in_args) {
    
    cString args(in_args);
    if (args == "") fname="instruction.dat"; else fname=args.PopWord();
  }
  ///// print_instruction_data /////
  void Process(){
    population->GetStats().PrintInstructionData(fname);
  }
};

///// print_instruction_abundance_histogram /////

/**
*
 * Appends a line containing the bulk count (abundance) of
 * each instruction in the population onto a file.
 *
 * Parameters:
 * filename (string) default: "instruction_histogram.dat"
   *
   **/


class cPopulationEventprint_instruction_abundance_histogram : public cPopulationEvent {
private:
  cString filename;
public:
  cPopulationEventprint_instruction_abundance_histogram(const cString & in_args):
  cPopulationEvent("print_instruction_abundance_histogram", in_args) {
    
    cString args(in_args);
    if (args == "") filename="instruction_histogram.dat"; else filename=args.PopWord();
  }
  ///// print_instruction_abundance_histogram /////
  void Process(){
    ofstream & fp = population->GetStats().GetDataFileOFStream(filename);
    cAnalyzeUtil::PrintInstructionAbundanceHistogram(fp, population);
  }
};

///// print_depth_histogram /////

/**
**/


class cPopulationEventprint_depth_histogram : public cPopulationEvent {
private:
  cString filename;
public:
  cPopulationEventprint_depth_histogram(const cString & in_args):
  cPopulationEvent("print_depth_histogram", in_args) {
    
    cString args(in_args);
    if (args == "") filename="depth_histogram.dat"; else filename=args.PopWord();
  }
  ///// print_depth_histogram /////
  void Process(){
    ofstream & fp = population->GetStats().GetDataFileOFStream(filename);
    cAnalyzeUtil::PrintDepthHistogram(fp, population);
  }
};

///// print_genotype_abundance_histogram /////

/**
* Writes out a genotype abundance histogram.
 *
 * Parameters:
 * filename (string) default: genotype_abundance_histogram.dat
   *   The name of the file into which the histogram is written.
   **/


class cPopulationEventprint_genotype_abundance_histogram : public cPopulationEvent {
private:
  cString filename;
public:
  cPopulationEventprint_genotype_abundance_histogram(const cString & in_args):
  cPopulationEvent("print_genotype_abundance_histogram", in_args) {
    
    cString args(in_args);
    if (args == "") filename="genotype_abundance_histogram.dat"; else filename=args.PopWord();
  }
  ///// print_genotype_abundance_histogram /////
  void Process(){
    ofstream & fp = population->GetStats().GetDataFileOFStream(filename);
    cAnalyzeUtil::PrintGenotypeAbundanceHistogram(fp, population);
  }
};

///// print_species_abundance_histogram /////

/**
* Writes out a species abundance histogram.
 *
 * Parameters:
 * filename (string) default: species_abundance_histogram.dat
   *   The name of the file into which the histogram is written.
   **/


class cPopulationEventprint_species_abundance_histogram : public cPopulationEvent {
private:
  cString filename;
public:
  cPopulationEventprint_species_abundance_histogram(const cString & in_args):
  cPopulationEvent("print_species_abundance_histogram", in_args) {
    
    cString args(in_args);
    if (args == "") filename="species_abundance_histogram.dat"; else filename=args.PopWord();
  }
  ///// print_species_abundance_histogram /////
  void Process(){
    ofstream & fp = population->GetStats().GetDataFileOFStream(filename);
    cAnalyzeUtil::PrintSpeciesAbundanceHistogram(fp, population);
  }
};

///// print_lineage_totals /////

/**
**/


class cPopulationEventprint_lineage_totals : public cPopulationEvent {
private:
  cString fname;
  int verbose;
public:
    cPopulationEventprint_lineage_totals(const cString & in_args):
    cPopulationEvent("print_lineage_totals", in_args) {
      
      cString args(in_args);
      if (args == "") fname="lineage_totals.dat"; else fname=args.PopWord();
      if (args == "") verbose=1; else verbose=args.PopWord().AsInt();
    }
  ///// print_lineage_totals /////
  void Process(){
    static bool msg_printed = false;
    if (population->GetLineageControl() == NULL) {
      if ( msg_printed == false ){
        ofstream & fp = population->GetStats().GetDataFileOFStream(fname);
        fp << "No lineage data available!" << endl;
        msg_printed = true;
      }
      return;
    }
    population->GetLineageControl()->PrintLineageTotals(fname, verbose);
  }
};

///// print_lineage_counts /////

/**
**/


class cPopulationEventprint_lineage_counts : public cPopulationEvent {
private:
  cString fname;
  int verbose;
public:
    cPopulationEventprint_lineage_counts(const cString & in_args):
    cPopulationEvent("print_lineage_counts", in_args) {
      
      cString args(in_args);
      if (args == "") fname="lineage_counts.dat"; else fname=args.PopWord();
      if (args == "") verbose=0; else verbose=args.PopWord().AsInt();
    }
  ///// print_lineage_counts /////
  void Process(){
    static bool msg_printed = false;
    if (population->GetLineageControl() == NULL) {
      if ( msg_printed == false ){
        ofstream & fp = population->GetStats().GetDataFileOFStream(fname);
        fp << "No lineage data available!" << endl;
        msg_printed = true;
      }
      return;
    }
    if (verbose) {    // verbose mode is the same in both methods
      population->GetLineageControl()->PrintLineageTotals(fname, verbose);
      return;
    }
    population->GetLineageControl()->PrintLineageCurCounts(fname);
  }
};

///// print_dom /////

/**
* Write the currently dominant genotype to disk.
 *
 * Parameters:
 * filename (string)
 *   The name under which the genotype should be saved. If no
 *   filename is given, the genotype is saved into the directory
 *   genebank, under the name that the genebank has associated with
 *   this genotype.
 **/


class cPopulationEventprint_dom : public cPopulationEvent {
private:
  cString in_filename;
public:
  cPopulationEventprint_dom(const cString & in_args):
  cPopulationEvent("print_dom", in_args) {
    
    cString args(in_args);
    if (args == "") in_filename=""; else in_filename=args.PopWord();
  }
  ///// print_dom /////
  void Process(){
    cGenotype * dom = population->GetGenebank().GetBestGenotype();
    cString filename(in_filename);
    if (filename == "") filename.Set("genebank/%s", dom->GetName()());
    cTestUtil::PrintGenome(dom->GetGenome(), filename, dom, population->GetUpdate());
  }
};

///// parasite_debug /////

//midget


class cPopulationEventparasite_debug : public cPopulationEvent {
private:
  cString in_filename;
public:
  cPopulationEventparasite_debug(const cString & in_args):
  cPopulationEvent("parasite_debug", in_args) {
    
    cString args(in_args);
    if (args == "") in_filename=""; else in_filename=args.PopWord();
  }
  ///// parasite_debug /////
  void Process(){
    population->ParasiteDebug();
  }
};

///// print_dom_parasite /////

/**
* Write the currently dominant injected genotype to disk.
 *
 * Parameters:
 * filename (string)
 *   The name under which the genotype should be saved. If no
 *   filename is given, the genotype is saved into the directory
 *   genebank, under the name that the genebank has associated with
 *   this genotype.
 **/


class cPopulationEventprint_dom_parasite : public cPopulationEvent {
private:
  cString in_filename;
public:
  cPopulationEventprint_dom_parasite(const cString & in_args):
  cPopulationEvent("print_dom_parasite", in_args) {
    
    cString args(in_args);
    if (args == "") in_filename=""; else in_filename=args.PopWord();
  }
  ///// print_dom_parasite /////
  void Process(){
    cInjectGenotype * dom = population->GetInjectGenebank().GetBestInjectGenotype();
    if (dom!=NULL) {
      cString filename(in_filename);
      if (filename == "") filename.Set("genebank/%s", dom->GetName()());
      cTestUtil::PrintGenome(dom, dom->GetGenome(), filename, population->GetUpdate()); }
  }
};

///// print_genotype_map /////

/**
* write a matrix of genotype ID's to a file (matlab format)
 **/


class cPopulationEventprint_genotype_map : public cPopulationEvent {
private:
  cString fname;
public:
  cPopulationEventprint_genotype_map(const cString & in_args):
  cPopulationEvent("print_genotype_map", in_args) {
    
    cString args(in_args);
    if (args == "") fname="genotype_map.m"; else fname=args.PopWord();
  }
  ///// print_genotype_map /////
  void Process(){
    population->GetStats().PrintGenotypeMap(fname);
  }
};

///// print_number_phenotypes /////

/**
Output file with number of phenotypes based on tasks executed
 for this update.  Executing a task any numbers of times is considered
 the same as executing it once.
 **/


class cPopulationEventprint_number_phenotypes : public cPopulationEvent {
private:
  cString fname;
public:
  cPopulationEventprint_number_phenotypes(const cString & in_args):
  cPopulationEvent("print_number_phenotypes", in_args) {
    
    cString args(in_args);
    if (args == "") fname="phenotype_count.dat"; else fname=args.PopWord();
  }
  ///// print_number_phenotypes /////
  void Process(){
    population->PrintPhenotypeData(fname);
  }
};

///// print_phenotype_status /////

/**
Prints merit status for all the organisms in the population.
 Used for testing/debuging. 
 **/


class cPopulationEventprint_phenotype_status : public cPopulationEvent {
private:
  cString fname;
public:
  cPopulationEventprint_phenotype_status(const cString & in_args):
  cPopulationEvent("print_phenotype_status", in_args) {
    
    cString args(in_args);
    if (args == "") fname="phenotype_status.dat"; else fname=args.PopWord();
  }
  ///// print_phenotype_status /////
  void Process(){
    population->PrintPhenotypeStatus(fname);
  }
};

///// save_population /////

/**
* Saves the full state of the population.
 *
 * Parameters:
 * filename (string) default: save_pop.*
   *   The name of the file into which the population should
   *   be saved. If it is not given, then the name 'save_pop.*'
   *   is used, with '*' replaced by the current update.
   **/


class cPopulationEventsave_population : public cPopulationEvent {
private:
  cString fname;
public:
  cPopulationEventsave_population(const cString & in_args):
  cPopulationEvent("save_population", in_args) {
    
    cString args(in_args);
    if (args == "") fname=""; else fname=args.PopWord();
  }
  ///// save_population /////
  void Process(){
    cString filename;
    if( fname == "" ){
      filename.Set("save_pop.%d", population->GetUpdate());
    }
    ofstream fp(filename());
    population->SavePopulation(fp);
  }
};

///// load_population /////

/**
* Loads the full state of the population.
 *
 * Parameters:
 * filename (string)
 *   The name of the file to open.
 **/


class cPopulationEventload_population : public cPopulationEvent {
private:
  cString fname;
public:
  cPopulationEventload_population(const cString & in_args):
  cPopulationEvent("load_population", in_args) {
    
    cString args(in_args);
    fname = args.PopWord();
  }
  ///// load_population /////
  void Process(){
    ifstream fp(fname());
    population->LoadPopulation(fp);
  }
};

///// save_clone /////

/**
**/


class cPopulationEventsave_clone : public cPopulationEvent {
private:
  cString fname;
public:
  cPopulationEventsave_clone(const cString & in_args):
  cPopulationEvent("save_clone", in_args) {
    
    cString args(in_args);
    if (args == "") fname=""; else fname=args.PopWord();
  }
  ///// save_clone /////
  void Process(){
    cString filename;
    if( fname == "" ){
      filename.Set("clone.%d", population->GetUpdate());
    }
    ofstream fp(filename());
    population->SaveClone(fp);
  }
};

///// load_clone /////

/**
**/


class cPopulationEventload_clone : public cPopulationEvent {
private:
  cString fname;
public:
  cPopulationEventload_clone(const cString & in_args):
  cPopulationEvent("load_clone", in_args) {
    
    cString args(in_args);
    fname = args.PopWord();
  }
  ///// load_clone /////
  void Process(){
    ifstream fp(fname());
    population->LoadClone(fp);
  }
};

///// load_dump_file /////

/**
* Sets up a population based on a dump file such as written out by
 * detail_pop. It is also possible to append a history file to the dump
 * file, in order to preserve the history of a previous run.
 **/


class cPopulationEventload_dump_file : public cPopulationEvent {
private:
  cString fname;
  int update;
public:
    cPopulationEventload_dump_file(const cString & in_args):
    cPopulationEvent("load_dump_file", in_args) {
      
      cString args(in_args);
      fname = args.PopWord();
      if (args == "") update=-1; else update=args.PopWord().AsInt();
    }
  ///// load_dump_file /////
  void Process(){
    population->LoadDumpFile(fname, update);
  }
};

///// dump_pop /////

/**
* Writes out a line of data for each genotype in the current population. The
 * line contains the genome as string, the number of organisms of that genotype,
 * and the genotype ID.
 *
 * Parameters:
 * filename (string) default: "dump.<update>"
   *   The name of the file into which the population dump should be written.
   **/


class cPopulationEventdump_pop : public cPopulationEvent {
private:
  cString fname;
public:
  cPopulationEventdump_pop(const cString & in_args):
  cPopulationEvent("dump_pop", in_args) {
    
    cString args(in_args);
    if (args == "") fname=""; else fname=args.PopWord();
  }
  ///// dump_pop /////
  void Process(){
    cString filename;
    if( fname == "" ){
      filename.Set("dump.%d", population->GetUpdate());
    }
    ofstream fp(filename());
    population->GetGenebank().DumpTextSummary(fp);
  }
};

///// print_genotypes /////

/**
* This is a new version of "detail_pop" or "historic_dump".  It allows you to
 * output one line per genotype in memory where you get to choose what data
 * should be included.
 *
 * Parameters
 * data_fields (string)
 *   This must be a comma separated string of all data you wish to output.
 *   Options include: id, parent_id, parent2_id (for sex), parent_dist,
 *       num_cpus, total_cpus, length, merit, gest_time, fitness, update_born,
 *       update_dead, depth, lineage, sequence
 * historic (int) default: 0
   *   How many updates back of history should we include (-1 = all)
   * filename (string) default: "genotypes-<update>.dat"
     *   The name of the file into which the population dump should be written.
     **/


class cPopulationEventprint_genotypes : public cPopulationEvent {
private:
  cString data_fields;
  int historic;
  cString fname;
public:
    cPopulationEventprint_genotypes(const cString & in_args):
    cPopulationEvent("print_genotypes", in_args) {
      
      cString args(in_args);
      if (args == "") data_fields="all"; else data_fields=args.PopWord();
      if (args == "") historic=0; else historic=args.PopWord().AsInt();
      if (args == "") fname=""; else fname=args.PopWord();
    }
  ///// print_genotypes /////
  void Process(){
    cString filename = fname;
    if (filename == "") {
      filename.Set("genotypes-%d.dat", population->GetUpdate());
    }
    ofstream fp(filename());
    population->GetGenebank().PrintGenotypes(fp, data_fields, historic);
  }
};

///// detail_pop /////

/**
* Like dump_pop, but more detailed data is written out.
 *
 * Parameters:
 * filename (string) default: "detail_pop.<update>"
   *   The name of the file into which the population dump should be written.
   **/


class cPopulationEventdetail_pop : public cPopulationEvent {
private:
  cString fname;
public:
  cPopulationEventdetail_pop(const cString & in_args):
  cPopulationEvent("detail_pop", in_args) {
    
    cString args(in_args);
    if (args == "") fname=""; else fname=args.PopWord();
  }
  ///// detail_pop /////
  void Process(){
    cString filename;
    if( fname == "" ){
      filename.Set("detail_pop.%d", population->GetUpdate());
    }
    ofstream fp(filename());
    population->GetGenebank().DumpDetailedSummary(fp);
  }
};

///// detail_sex_pop /////

/**
* Like detail_pop, but for sexual populations. 
 * Info for both parents is writen out.
 *
 * Parameters:
 * filename (string) default: "detail_pop.<update>"
   *   The name of the file into which the population dump should be written.
   **/


class cPopulationEventdetail_sex_pop : public cPopulationEvent {
private:
  cString fname;
public:
  cPopulationEventdetail_sex_pop(const cString & in_args):
  cPopulationEvent("detail_sex_pop", in_args) {
    
    cString args(in_args);
    if (args == "") fname=""; else fname=args.PopWord();
  }
  ///// detail_sex_pop /////
  void Process(){
    cString filename;
    if( fname == "" ){
      filename.Set("detail_pop.%d", population->GetUpdate());
    }
    ofstream fp(filename());
    population->GetGenebank().DumpDetailedSexSummary(fp);
  }
};

///// detail_parasite_pop /////

/**
* Like dump_pop, but more detailed data is written out.
 *
 * Parameters:
 * filename (string) default: "detail_pop.<update>"
   *   The name of the file into which the population dump should be written.
   **/


class cPopulationEventdetail_parasite_pop : public cPopulationEvent {
private:
  cString fname;
public:
  cPopulationEventdetail_parasite_pop(const cString & in_args):
  cPopulationEvent("detail_parasite_pop", in_args) {
    
    cString args(in_args);
    if (args == "") fname=""; else fname=args.PopWord();
  }
  ///// detail_parasite_pop /////
  void Process(){
    cString filename;
    if( fname == "" ){
      filename.Set("detail_parasite_pop.%d", population->GetUpdate());
    }
    //ofstream fp(filename());
    population->GetInjectGenebank().DumpDetailedSummary(filename, population->GetUpdate());
  }
};

///// dump_historic_pop /////

/**
* Similar to detail_pop. However, only genotypes that are not in the
 * current population anymore are included. Genotypes that are not in
 * the line of descent of any of the current genotypes to the ultimate
 * ancestor are excluded.
 *
 * Parameters:
 * back_dist (int) default: -1
   *   How many updates back should we print?  -1 goes forever.  Use the
   *   distance to the last dump historic if you only want a "diff".
     * filename (string) default: "historic_dump.<update>"
       *   The name of the file into which the historic dump should be written.
       **/


class cPopulationEventdump_historic_pop : public cPopulationEvent {
private:
  int back_dist;
  cString fname;
public:
    cPopulationEventdump_historic_pop(const cString & in_args):
    cPopulationEvent("dump_historic_pop", in_args) {
      
      cString args(in_args);
      if (args == "") back_dist=-1; else back_dist=args.PopWord().AsInt();
      if (args == "") fname=""; else fname=args.PopWord();
    }
  ///// dump_historic_pop /////
  void Process(){
    cString filename;
    if( fname == "" ){
      filename.Set("historic_dump.%d", population->GetUpdate());
    }
    ofstream fp(filename());
    population->GetGenebank().DumpHistoricSummary(fp, back_dist);
  }
};

///// dump_historic_sex_pop /////

/**
* Similar to dump_historic_pop, but for sexual populations. 
 * ID of both parents is writen out. 
 *
 * Parameters:
 * filename (string) default: "historic_dump.<update>"
   *   The name of the file into which the historic dump should be written.
   **/


class cPopulationEventdump_historic_sex_pop : public cPopulationEvent {
private:
  cString fname;
public:
  cPopulationEventdump_historic_sex_pop(const cString & in_args):
  cPopulationEvent("dump_historic_sex_pop", in_args) {
    
    cString args(in_args);
    if (args == "") fname=""; else fname=args.PopWord();
  }
  ///// dump_historic_sex_pop /////
  void Process(){
    cString filename;
    if( fname == "" ){
      filename.Set("historic_dump.%d", population->GetUpdate());
    }
    ofstream fp(filename());
    population->GetGenebank().DumpHistoricSexSummary(fp);
  }
};

///// dump_memory /////

/**
* Dump the current memory state of all CPUs to a file.
 **/


class cPopulationEventdump_memory : public cPopulationEvent {
private:
  cString fname;
public:
  cPopulationEventdump_memory(const cString & in_args):
  cPopulationEvent("dump_memory", in_args) {
    
    cString args(in_args);
    if (args == "") fname=""; else fname=args.PopWord();
  }
  ///// dump_memory /////
  void Process(){
    cString filename;
    if (fname == "") {
      filename.Set("memory_dump.%d", population->GetUpdate());
    }
    ofstream fp(filename());
    population->DumpMemorySummary(fp);
  }
};

///// inject /////

/**
* Injects a single organism into the population.
 *
 * Parameters:
 * filename (string)
 *   The filename of the genotype to load. If this is left empty, or the keyword
 *   "START_CREATURE" is given, than the genotype specified in the genesis
 *   file under "START_CREATURE" is used.
 * cell ID (integer) default: 0
   *   The grid-point into which the organism should be placed.
   * merit (double) default: -1
     *   The initial merit of the organism. If set to -1, this is ignored.
     * lineage label (integer) default: 0
       *   An integer that marks all descendants of this organism.
       * neutral metric (double) default: 0
         *   A double value that randomly drifts over time.
         **/


class cPopulationEventinject : public cPopulationEvent {
private:
  cString fname;
  int cell_id;
  double merit;
  int lineage_label;
  double neutral_metric;
public:
    cPopulationEventinject(const cString & in_args):
    cPopulationEvent("inject", in_args) {
      
      cString args(in_args);
      if (args == "") fname="START_CREATURE"; else fname=args.PopWord();
      if (args == "") cell_id=0; else cell_id=args.PopWord().AsInt();
      if (args == "") merit=-1; else merit=args.PopWord().AsDouble();
      if (args == "") lineage_label=0; else lineage_label=args.PopWord().AsInt();
      if (args == "") neutral_metric=0; else neutral_metric=args.PopWord().AsDouble();
    }
  ///// inject /////
  void Process(){
    if (fname == "START_CREATURE") fname=cConfig::GetStartCreature();
    cGenome genome =
      cInstUtil::LoadGenome(fname, population->GetEnvironment().GetInstSet());
    population->Inject(genome, cell_id, merit, lineage_label, neutral_metric);
  }
};

///// inject_all /////

/**
* Injects identical organisms into all cells of the population.
 *
 * Parameters:
 * filename (string)
 *   The filename of the genotype to load. If this is left empty, or the keyword
 *   "START_CREATURE" is given, than the genotype specified in the genesis
 *   file under "START_CREATURE" is used.
 * merit (double) default: -1
   *   The initial merit of the organism. If set to -1, this is ignored.
   * lineage label (integer) default: 0
     *   An integer that marks all descendants of this organism.
     * neutral metric (double) default: 0
       *   A double value that randomly drifts over time.
       **/


class cPopulationEventinject_all : public cPopulationEvent {
private:
  cString fname;
  double merit;
  int lineage_label;
  double neutral_metric;
public:
    cPopulationEventinject_all(const cString & in_args):
    cPopulationEvent("inject_all", in_args) {
      
      cString args(in_args);
      if (args == "") fname="START_CREATURE"; else fname=args.PopWord();
      if (args == "") merit=-1; else merit=args.PopWord().AsDouble();
      if (args == "") lineage_label=0; else lineage_label=args.PopWord().AsInt();
      if (args == "") neutral_metric=0; else neutral_metric=args.PopWord().AsDouble();
    }
  ///// inject_all /////
  void Process(){
    if (fname == "START_CREATURE") fname=cConfig::GetStartCreature();
    cGenome genome =
      cInstUtil::LoadGenome(fname, population->GetEnvironment().GetInstSet());
    for (int i = 0; i < population->GetSize(); i++) {
      population->Inject(genome, i, merit, lineage_label, neutral_metric);
    }
    population->SetSyncEvents(true);
  }
};

///// inject_range /////

/**
* Injects identical organisms into a range of cells of the population.
 *
 * Parameters:
 * filename (string)
 *   The filename of the genotype to load. If this is left empty, or the keyword
 *   "START_CREATURE" is given, than the genotype specified in the genesis
 *   file under "START_CREATURE" is used.
 * start_cell (int)
 *   First cell to inject into.
 * stop_cell (int)
 *   First cell *not* to inject into.
 * merit (double) default: -1
   *   The initial merit of the organism. If set to -1, this is ignored.
   * lineage label (integer) default: 0
     *   An integer that marks all descendants of this organism.
     * neutral metric (double) default: 0
       *   A double value that randomly drifts over time.
       *
       * Example:
       *   inject_range creature.gen 0 10
       *
       * Will inject 10 organisms into cells 0 through 9.
       **/


class cPopulationEventinject_range : public cPopulationEvent {
private:
  cString fname;
  int start_cell;
  int end_cell;
  double merit;
  int lineage_label;
  double neutral_metric;
public:
    cPopulationEventinject_range(const cString & in_args):
    cPopulationEvent("inject_range", in_args) {
      
      cString args(in_args);
      if (args == "") fname="START_CREATURE"; else fname=args.PopWord();
      if (args == "") start_cell=0; else start_cell=args.PopWord().AsInt();
      if (args == "") end_cell=-1; else end_cell=args.PopWord().AsInt();
      if (args == "") merit=-1; else merit=args.PopWord().AsDouble();
      if (args == "") lineage_label=0; else lineage_label=args.PopWord().AsInt();
      if (args == "") neutral_metric=0; else neutral_metric=args.PopWord().AsDouble();
    }
  ///// inject_range /////
  void Process(){
    if (fname == "START_CREATURE") fname=cConfig::GetStartCreature();
    if (end_cell == -1) end_cell = start_cell + 1;
    if (start_cell < 0 ||
        end_cell > population->GetSize() ||
        start_cell >= end_cell) {
      cout << "Warning: inject_range has invalid range!";
    }
    else {
      cGenome genome =
      cInstUtil::LoadGenome(fname, population->GetEnvironment().GetInstSet());
      for (int i = start_cell; i < end_cell; i++) {
        population->Inject(genome, i, merit, lineage_label, neutral_metric);
      }
      population->SetSyncEvents(true);
    }
  }
};

///// inject_sequence /////

/**
* Injects identical organisms into a range of cells of the population.
 *
 * Parameters:
 * sequence (string)
 *   The genome sequence for this organism.  This is a mandatory argument.
 * start_cell (int)
 *   First cell to inject into.
 * stop_cell (int)
 *   First cell *not* to inject into.
 * merit (double) default: -1
   *   The initial merit of the organism. If set to -1, this is ignored.
   * lineage label (integer) default: 0
     *   An integer that marks all descendants of this organism.
     * neutral metric (double) default: 0
       *   A double value that randomly drifts over time.
       *
       * Example:
       *   inject_range ckdfhgklsahnfsaggdsgajfg 0 10 100
       *
       * Will inject 10 organisms into cells 0 through 9 with a merit of 100.
       **/


class cPopulationEventinject_sequence : public cPopulationEvent {
private:
  cString seq;
  int start_cell;
  int end_cell;
  double merit;
  int lineage_label;
  double neutral_metric;
public:
    cPopulationEventinject_sequence(const cString & in_args):
    cPopulationEvent("inject_sequence", in_args) {
      
      cString args(in_args);
      seq = args.PopWord();
      if (args == "") start_cell=0; else start_cell=args.PopWord().AsInt();
      if (args == "") end_cell=-1; else end_cell=args.PopWord().AsInt();
      if (args == "") merit=-1; else merit=args.PopWord().AsDouble();
      if (args == "") lineage_label=0; else lineage_label=args.PopWord().AsInt();
      if (args == "") neutral_metric=0; else neutral_metric=args.PopWord().AsDouble();
    }
  ///// inject_sequence /////
  void Process(){
    if (end_cell == -1) end_cell = start_cell + 1;
    if (start_cell < 0 ||
        end_cell > population->GetSize() ||
        start_cell >= end_cell) {
      cout << "Warning: inject_sequence has invalid range!" << endl;
      cout << "start=" << start_cell << "  end=" << end_cell
        << "genome length=" << seq.GetSize() << endl;
    }
    else {
      cGenome genome(seq);
      for (int i = start_cell; i < end_cell; i++) {
        population->Inject(genome, i, merit, lineage_label, neutral_metric);
      }
      population->SetSyncEvents(true);
    }
  }
};

///// inject_random /////

/**
* Injects a randomly generated genome into the population.
 *
 * Parameters:
 * length (integer) [required]
 *   Number of instructions in the randomly generated genome.
 * cell ID (integer) default: -1
   *   The grid-point into which the genome should be placed.  Default is random.
   * merit (double) default: -1
     *   The initial merit of the organism. If set to -1, this is ignored.
     * lineage label (integer) default: 0
       *   An integer that marks all descendants of this organism.
       * neutral metric (double) default: 0
         *   A double value that randomly drifts over time.
         **/


class cPopulationEventinject_random : public cPopulationEvent {
private:
  int length;
  int cell_id;
  double merit;
  int lineage_label;
  double neutral_metric;
public:
    cPopulationEventinject_random(const cString & in_args):
    cPopulationEvent("inject_random", in_args) {
      
      cString args(in_args);
      length = args.PopWord().AsInt();
      if (args == "") cell_id=-1; else cell_id=args.PopWord().AsInt();
      if (args == "") merit=-1; else merit=args.PopWord().AsDouble();
      if (args == "") lineage_label=0; else lineage_label=args.PopWord().AsInt();
      if (args == "") neutral_metric=0; else neutral_metric=args.PopWord().AsDouble();
    }
  ///// inject_random /////
  void Process(){
    if (cell_id == -1) cell_id = g_random.GetUInt(population->GetSize());
    cGenome genome =
      cInstUtil::RandomGenome(length, population->GetEnvironment().GetInstSet());
    population->Inject(genome, cell_id, merit, lineage_label, neutral_metric);
  }
};

///// inject_range_parasite /////

/**
* Injects identical organisms into a range of cells of the population.
 *
 * Parameters:
 * filename (string)
 *   The filename of the genotype to load. If this is left empty, or the keyword
 *   "START_CREATURE" is given, than the genotype specified in the genesis
 *   file under "START_CREATURE" is used.
 * start_cell (int)
 *   First cell to inject into.
 * stop_cell (int)
 *   First cell *not* to inject into.
 * merit (double) default: -1
   *   The initial merit of the organism. If set to -1, this is ignored.
   * lineage label (integer) default: 0
     *   An integer that marks all descendants of this organism.
     * neutral metric (double) default: 0
       *   A double value that randomly drifts over time.
       *
       * Example:
       *   inject_range creature.gen 0 10
       *
       * Will inject 10 organisms into cells 0 through 9.
       **/


class cPopulationEventinject_range_parasite : public cPopulationEvent {
private:
  cString fname_parasite;
  int start_cell;
  int end_cell;
  double merit;
  int lineage_label;
  double neutral_metric;
  int mem_space;
public:
    cPopulationEventinject_range_parasite(const cString & in_args):
    cPopulationEvent("inject_range_parasite", in_args) {
      
      cString args(in_args);
      if (args == "") fname_parasite="organism.parasite"; else fname_parasite=args.PopWord();
      if (args == "") start_cell=0; else start_cell=args.PopWord().AsInt();
      if (args == "") end_cell=-1; else end_cell=args.PopWord().AsInt();
      if (args == "") merit=-1; else merit=args.PopWord().AsDouble();
      if (args == "") lineage_label=0; else lineage_label=args.PopWord().AsInt();
      if (args == "") neutral_metric=0; else neutral_metric=args.PopWord().AsDouble();
      if (args == "") mem_space=2; else mem_space=args.PopWord().AsInt();
    }
  ///// inject_range_parasite /////
  void Process(){
    if (fname_parasite == "START_CREATURE") fname_parasite=cConfig::GetStartCreature();
    if (end_cell == -1) end_cell = start_cell + 1;
    if (start_cell < 0 ||
        end_cell > population->GetSize() ||
        start_cell >= end_cell) {
      cout << "Warning: inject_range has invalid range!";
    }
    else {
      cGenome genome_parasite =
      cInstUtil::LoadGenome(fname_parasite, population->GetEnvironment().GetInstSet());
      for (int i = start_cell; i < end_cell; i++) {
        population->Inject(genome_parasite, i, merit, lineage_label, neutral_metric, mem_space);
      }
      population->SetSyncEvents(true);
    }
  }
};

///// inject_range_pair /////

/**
* Injects identical organisms into a range of cells of the population.
 *
 * Parameters:
 * filename (string)
 *   The filename of the genotype to load. If this is left empty, or the keyword
 *   "START_CREATURE" is given, than the genotype specified in the genesis
 *   file under "START_CREATURE" is used.
 * start_cell (int)
 *   First cell to inject into.
 * stop_cell (int)
 *   First cell *not* to inject into.
 * merit (double) default: -1
   *   The initial merit of the organism. If set to -1, this is ignored.
   * lineage label (integer) default: 0
     *   An integer that marks all descendants of this organism.
     * neutral metric (double) default: 0
       *   A double value that randomly drifts over time.
       *
       * Example:
       *   inject_range creature.gen 0 10
       *
       * Will inject 10 organisms into cells 0 through 9.
       **/


class cPopulationEventinject_range_pair : public cPopulationEvent {
private:
  cString fname;
  cString fname_parasite;
  int start_cell;
  int end_cell;
  double merit;
  int lineage_label;
  double neutral_metric;
  int mem_space;
public:
    cPopulationEventinject_range_pair(const cString & in_args):
    cPopulationEvent("inject_range_pair", in_args) {
      
      cString args(in_args);
      if (args == "") fname="START_CREATURE"; else fname=args.PopWord();
      if (args == "") fname_parasite="organism.parasite"; else fname_parasite=args.PopWord();
      if (args == "") start_cell=0; else start_cell=args.PopWord().AsInt();
      if (args == "") end_cell=-1; else end_cell=args.PopWord().AsInt();
      if (args == "") merit=-1; else merit=args.PopWord().AsDouble();
      if (args == "") lineage_label=0; else lineage_label=args.PopWord().AsInt();
      if (args == "") neutral_metric=0; else neutral_metric=args.PopWord().AsDouble();
      if (args == "") mem_space=2; else mem_space=args.PopWord().AsInt();
    }
  ///// inject_range_pair /////
  void Process(){
    if (fname == "START_CREATURE") fname=cConfig::GetStartCreature();
    if (end_cell == -1) end_cell = start_cell + 1;
    if (start_cell < 0 ||
        end_cell > population->GetSize() ||
        start_cell >= end_cell) {
      cout << "Warning: inject_range has invalid range!";
    }
    else {
      cGenome genome =
      cInstUtil::LoadGenome(fname, population->GetEnvironment().GetInstSet());
      cGenome genome_parasite =
        cInstUtil::LoadGenome(fname_parasite, population->GetEnvironment().GetInstSet());
      for (int i = start_cell; i < end_cell; i++) {
        population->Inject(genome, i, merit, lineage_label, neutral_metric);
        population->Inject(genome_parasite, i, merit, lineage_label, neutral_metric, mem_space);
      }
      population->SetSyncEvents(true);
    }
  }
};

///// zero_muts /////

/**
* This event will set all mutation rates to zero...
 **/


class cPopulationEventzero_muts : public cPopulationEvent {
private:
public:
  cPopulationEventzero_muts(const cString & in_args):
  cPopulationEvent("zero_muts", in_args) {
    (void)in_args; }
  ///// zero_muts /////
  void Process(){
    for (int i = 0; i < population->GetSize(); i++) {
      population->GetCell(i).MutationRates().Clear();
    }
  }
};

///// mod_copy_mut /////

/**
**/


class cPopulationEventmod_copy_mut : public cPopulationEvent {
private:
  double cmut_inc;
  int cell;
public:
    cPopulationEventmod_copy_mut(const cString & in_args):
    cPopulationEvent("mod_copy_mut", in_args) {
      
      cString args(in_args);
      cmut_inc = args.PopWord().AsDouble();
      if (args == "") cell=-1; else cell=args.PopWord().AsInt();
    }
  ///// mod_copy_mut /////
  void Process(){
    const double new_cmut = cConfig::GetCopyMutProb() + cmut_inc;
    if (cell < 0) {   // cell == -1  -->  all
      for (int i = 0; i < population->GetSize(); i++) {
        population->GetCell(i).MutationRates().SetCopyMutProb(new_cmut);
      }
      cConfig::SetCopyMutProb(new_cmut);
    } else {
      population->GetCell(cell).MutationRates().SetCopyMutProb(new_cmut);
    }
  }
};

///// mod_div_mut /////

/**
**/


class cPopulationEventmod_div_mut : public cPopulationEvent {
private:
  double dmut_inc;
  int cell;
public:
    cPopulationEventmod_div_mut(const cString & in_args):
    cPopulationEvent("mod_div_mut", in_args) {
      
      cString args(in_args);
      dmut_inc = args.PopWord().AsDouble();
      if (args == "") cell=-1; else cell=args.PopWord().AsInt();
    }
  ///// mod_div_mut /////
  void Process(){
    const double new_div_mut = cConfig::GetDivMutProb() + dmut_inc;
    if (cell < 0) {   // cell == -1  -->  all
      for (int i = 0; i < population->GetSize(); i++) {
        population->GetCell(i).MutationRates().SetDivMutProb(new_div_mut);
      }
      cConfig::SetDivMutProb(new_div_mut);
    } else {
      population->GetCell(cell).MutationRates().SetDivMutProb(new_div_mut);
    }
  }
};

///// set_copy_mut /////

/**
**/


class cPopulationEventset_copy_mut : public cPopulationEvent {
private:
  double cmut;
  int start_cell;
  int end_cell;
public:
    cPopulationEventset_copy_mut(const cString & in_args):
    cPopulationEvent("set_copy_mut", in_args) {
      
      cString args(in_args);
      cmut = args.PopWord().AsDouble();
      if (args == "") start_cell=-1; else start_cell=args.PopWord().AsInt();
      if (args == "") end_cell=-1; else end_cell=args.PopWord().AsInt();
    }
  ///// set_copy_mut /////
  void Process(){
    if (start_cell < 0) {   // start_cell == -1  -->  all
      cConfig::SetCopyMutProb(cmut);
      start_cell = 0;
      end_cell = population->GetSize();
    }
    else if (end_cell < -1)  { // end_cell == -1 --> Only one cell!
      end_cell = start_cell + 1;
    }
    assert(start_cell >= 0 && start_cell < population->GetSize());
    assert(end_cell > 0 && end_cell <= population->GetSize());
    for (int i = start_cell; i < end_cell; i++) {
      population->GetCell(i).MutationRates().SetCopyMutProb(cmut);
    }
  }
};

///// mod_point_mut /////

/**
**/


class cPopulationEventmod_point_mut : public cPopulationEvent {
private:
  double pmut_inc;
  int cell;
public:
    cPopulationEventmod_point_mut(const cString & in_args):
    cPopulationEvent("mod_point_mut", in_args) {
      
      cString args(in_args);
      pmut_inc = args.PopWord().AsDouble();
      if (args == "") cell=-1; else cell=args.PopWord().AsInt();
    }
  ///// mod_point_mut /////
  void Process(){
    const double new_pmut = cConfig::GetPointMutProb() + pmut_inc;
    if (cell < 0) {   // cell == -1   -->  all
      for (int i = 0; i < population->GetSize(); i++) {
        population->GetCell(i).MutationRates().SetPointMutProb(new_pmut);
      }
      cConfig::SetPointMutProb(new_pmut);
    } else {
      population->GetCell(cell).MutationRates().SetPointMutProb(new_pmut);
    }
  }
};

///// set_point_mut /////

/**
**/


class cPopulationEventset_point_mut : public cPopulationEvent {
private:
  double pmut;
  int cell;
public:
    cPopulationEventset_point_mut(const cString & in_args):
    cPopulationEvent("set_point_mut", in_args) {
      
      cString args(in_args);
      pmut = args.PopWord().AsDouble();
      if (args == "") cell=-1; else cell=args.PopWord().AsInt();
    }
  ///// set_point_mut /////
  void Process(){
    if (cell < 0) {   // cell == -1   -->  all
      for (int i = 0; i < population->GetSize(); i++) {
        population->GetCell(i).MutationRates().SetPointMutProb(pmut);
      }
      cConfig::SetPointMutProb(pmut);
    } else {
      population->GetCell(cell).MutationRates().SetPointMutProb(pmut);
    }
  }
};

///// calc_landscape /////

/**
**/


class cPopulationEventcalc_landscape : public cPopulationEvent {
private:
  int landscape_dist;
public:
  cPopulationEventcalc_landscape(const cString & in_args):
  cPopulationEvent("calc_landscape", in_args) {
    
    cString args(in_args);
    if (args == "") landscape_dist=1; else landscape_dist=args.PopWord().AsInt();
  }
  ///// calc_landscape /////
  void Process(){
    cGenome & genome = population->GetGenebank().GetBestGenotype()->GetGenome();
    cAnalyzeUtil::CalcLandscape(landscape_dist, genome,
                                population->GetEnvironment().GetInstSet());
  }
};

///// predict_w_landscape /////

/**
**/


class cPopulationEventpredict_w_landscape : public cPopulationEvent {
private:
  cString datafile;
public:
  cPopulationEventpredict_w_landscape(const cString & in_args):
  cPopulationEvent("predict_w_landscape", in_args) {
    
    cString args(in_args);
    if (args == "") datafile="land-predict.dat"; else datafile=args.PopWord();
  }
  ///// predict_w_landscape /////
  void Process(){
    cGenome & genome = population->GetGenebank().GetBestGenotype()->GetGenome();
    cLandscape landscape(genome, population->GetEnvironment().GetInstSet());
    static ofstream fp(datafile);
    landscape.PredictWProcess(fp);
  }
};

///// predict_nu_landscape /////

/**
**/


class cPopulationEventpredict_nu_landscape : public cPopulationEvent {
private:
  cString datafile;
public:
  cPopulationEventpredict_nu_landscape(const cString & in_args):
  cPopulationEvent("predict_nu_landscape", in_args) {
    
    cString args(in_args);
    if (args == "") datafile="land-predict.dat"; else datafile=args.PopWord();
  }
  ///// predict_nu_landscape /////
  void Process(){
    cGenome & genome = population->GetGenebank().GetBestGenotype()->GetGenome();
    cLandscape landscape(genome, population->GetEnvironment().GetInstSet());
    static ofstream fp(datafile);
    landscape.PredictNuProcess(fp);
  }
};

///// sample_landscape /////

/**
**/


class cPopulationEventsample_landscape : public cPopulationEvent {
private:
  int sample_size;
public:
  cPopulationEventsample_landscape(const cString & in_args):
  cPopulationEvent("sample_landscape", in_args) {
    
    cString args(in_args);
    if (args == "") sample_size=0; else sample_size=args.PopWord().AsInt();
  }
  ///// sample_landscape /////
  void Process(){
    cGenome & genome = population->GetGenebank().GetBestGenotype()->GetGenome();
    cLandscape landscape(genome, population->GetEnvironment().GetInstSet());
    if (sample_size == 0) sample_size = population->GetEnvironment().GetInstSet().GetSize() - 1;
    landscape.SampleProcess(sample_size);
    static ofstream fp("land-sample.dat");
    landscape.PrintStats(fp, population->GetUpdate());
  }
};

///// random_landscape /////

/**
**/


class cPopulationEventrandom_landscape : public cPopulationEvent {
private:
  int landscape_dist;
  int sample_size;
  int min_found;
  int max_sample_size;
  bool print_if_found;
public:
    cPopulationEventrandom_landscape(const cString & in_args):
    cPopulationEvent("random_landscape", in_args) {
      
      cString args(in_args);
      if (args == "") landscape_dist=1; else landscape_dist=args.PopWord().AsInt();
      if (args == "") sample_size=0; else sample_size=args.PopWord().AsInt();
      if (args == "") min_found=0; else min_found=args.PopWord().AsInt();
      if (args == "") max_sample_size=0; else max_sample_size=args.PopWord().AsInt();
      if (args == "") print_if_found=false; else print_if_found=args.PopWord();
    }
  ///// random_landscape /////
  void Process(){
    cGenome & genome = population->GetGenebank().GetBestGenotype()->GetGenome();
    cLandscape landscape(genome, population->GetEnvironment().GetInstSet());
    landscape.RandomProcess(sample_size, landscape_dist, min_found,
                            max_sample_size, print_if_found);
    static ofstream fp("land-random.dat");
    landscape.PrintStats(fp, population->GetUpdate());
  }
};

///// analyze_landscape /////

/**
**/


class cPopulationEventanalyze_landscape : public cPopulationEvent {
private:
  int sample_size;
  int min_found;
  int max_sample_size;
public:
    cPopulationEventanalyze_landscape(const cString & in_args):
    cPopulationEvent("analyze_landscape", in_args) {
      
      cString args(in_args);
      if (args == "") sample_size=1000; else sample_size=args.PopWord().AsInt();
      if (args == "") min_found=0; else min_found=args.PopWord().AsInt();
      if (args == "") max_sample_size=0; else max_sample_size=args.PopWord().AsInt();
    }
  ///// analyze_landscape /////
  void Process(){
    cGenome & genome = population->GetGenebank().GetBestGenotype()->GetGenome();
    cAnalyzeUtil::
    AnalyzeLandscape(genome, population->GetEnvironment().GetInstSet(),
                     sample_size, min_found, max_sample_size,
                     population->GetUpdate());
  }
};

///// pairtest_landscape /////

/**
* If sample_size = 0, pairtest the full landscape.
 **/


class cPopulationEventpairtest_landscape : public cPopulationEvent {
private:
  int sample_size;
public:
  cPopulationEventpairtest_landscape(const cString & in_args):
  cPopulationEvent("pairtest_landscape", in_args) {
    
    cString args(in_args);
    if (args == "") sample_size=0; else sample_size=args.PopWord().AsInt();
  }
  ///// pairtest_landscape /////
  void Process(){
    cGenome & genome = population->GetGenebank().GetBestGenotype()->GetGenome();
    cAnalyzeUtil::PairTestLandscape(genome, population->GetEnvironment().GetInstSet(), sample_size, population->GetUpdate());
  }
};

///// test_dom /////

/**
**/


class cPopulationEventtest_dom : public cPopulationEvent {
private:
public:
  cPopulationEventtest_dom(const cString & in_args):
  cPopulationEvent("test_dom", in_args) {
    (void)in_args; }
  ///// test_dom /////
  void Process(){
    cGenome & genome = population->GetGenebank().GetBestGenotype()->GetGenome();
    static ofstream fp("dom-test.dat");
    cAnalyzeUtil::TestGenome(genome, population->GetEnvironment().GetInstSet(), fp, population->GetUpdate());
  }
};

///// analyze_population /////

/**
**/


class cPopulationEventanalyze_population : public cPopulationEvent {
private:
  double sample_prob;
  int landscape;
  int save_genotype;
  cString filename;
public:
    cPopulationEventanalyze_population(const cString & in_args):
    cPopulationEvent("analyze_population", in_args) {
      
      cString args(in_args);
      if (args == "") sample_prob=1; else sample_prob=args.PopWord().AsDouble();
      if (args == "") landscape=0; else landscape=args.PopWord().AsInt();
      if (args == "") save_genotype=0; else save_genotype=args.PopWord().AsInt();
      if (args == "") filename=""; else filename=args.PopWord();
    }
  ///// analyze_population /////
  void Process(){
    static bool auto_filename = false;
    if( filename == "" )
      auto_filename = true;
    if ( auto_filename )
      filename.Set("population_info_%d.dat",population->GetUpdate());
    ofstream population_info(filename());
    cAnalyzeUtil::AnalyzePopulation(population, population_info, sample_prob,
                                    landscape, save_genotype);
  }
};

///// print_detailed_fitness_data /////

/**
**/


class cPopulationEventprint_detailed_fitness_data : public cPopulationEvent {
private:
  int save_max_f_genotype;
  int print_fitness_histo;
  double hist_fmax;
  double hist_fstep;
  cString filename;
  cString filename2;
  cString filename3;
public:
    cPopulationEventprint_detailed_fitness_data(const cString & in_args):
    cPopulationEvent("print_detailed_fitness_data", in_args) {
      
      cString args(in_args);
      if (args == "") save_max_f_genotype=0; else save_max_f_genotype=args.PopWord().AsInt();
      if (args == "") print_fitness_histo=0; else print_fitness_histo=args.PopWord().AsInt();
      if (args == "") hist_fmax=1; else hist_fmax=args.PopWord().AsDouble();
      if (args == "") hist_fstep=0.1; else hist_fstep=args.PopWord().AsDouble();
      if (args == "") filename="fitness.dat"; else filename=args.PopWord();
      if (args == "") filename2="fitness_histos.dat"; else filename2=args.PopWord();
      if (args == "") filename3="fitness_histos_testCPU.dat"; else filename3=args.PopWord();
    }
  ///// print_detailed_fitness_data /////
  void Process(){
    static ofstream datafile(filename());
    static ofstream histofile;
    static ofstream histofile_testCPU;
    if (print_fitness_histo && !histofile.is_open()){
      histofile.open(filename2());
      histofile_testCPU.open(filename3());
    }
    cAnalyzeUtil::PrintDetailedFitnessData( population, datafile, histofile, histofile_testCPU, save_max_f_genotype, print_fitness_histo, hist_fmax, hist_fstep );
  }
};

///// print_genetic_distance_data /////

/**
**/


class cPopulationEventprint_genetic_distance_data : public cPopulationEvent {
private:
  cString creature_name;
  cString filename;
public:
    cPopulationEventprint_genetic_distance_data(const cString & in_args):
    cPopulationEvent("print_genetic_distance_data", in_args) {
      
      cString args(in_args);
      if (args == "") creature_name=""; else creature_name=args.PopWord();
      if (args == "") filename="genetic_distance.dat"; else filename=args.PopWord();
    }
  ///// print_genetic_distance_data /////
  void Process(){
    static ofstream popdump(filename());
    if( creature_name == "" || creature_name == "START_CREATURE" ){
      creature_name = cConfig::GetStartCreature(); }
    cAnalyzeUtil::PrintGeneticDistanceData( population, popdump, creature_name() );
  }
};

///// genetic_distance_pop_dump /////

/**
**/


class cPopulationEventgenetic_distance_pop_dump : public cPopulationEvent {
private:
  cString creature_name;
  cString filename;
  int save_genotype;
public:
    cPopulationEventgenetic_distance_pop_dump(const cString & in_args):
    cPopulationEvent("genetic_distance_pop_dump", in_args) {
      
      cString args(in_args);
      if (args == "") creature_name=""; else creature_name=args.PopWord();
      if (args == "") filename=""; else filename=args.PopWord();
      if (args == "") save_genotype=0; else save_genotype=args.PopWord().AsInt();
    }
  ///// genetic_distance_pop_dump /////
  void Process(){
    static bool auto_filename = false;
    if( creature_name == "" || creature_name == "START_CREATURE" ){
      creature_name = cConfig::GetStartCreature(); }
    if( filename == "" || filename == "AUTO" )
      auto_filename = true;
    if ( auto_filename )
      filename.Set("pop_dump_%d.dat",population->GetUpdate());
    ofstream popdump(filename());
    cAnalyzeUtil::GeneticDistancePopDump( population, popdump, creature_name(), save_genotype );
  }
};

///// task_snapshot /////

/**
**/


class cPopulationEventtask_snapshot : public cPopulationEvent {
private:
  cString filename;
public:
  cPopulationEventtask_snapshot(const cString & in_args):
  cPopulationEvent("task_snapshot", in_args) {
    
    cString args(in_args);
    if (args == "") filename=""; else filename=args.PopWord();
  }
  ///// task_snapshot /////
  void Process(){
    static bool auto_filename = false;
    if( filename == "" )
      auto_filename = true;
    if ( auto_filename )
      filename.Set("tasks_%d.dat",population->GetUpdate());
    ofstream snapshot_file(filename());
    cAnalyzeUtil::TaskSnapshot( population, snapshot_file );
  }
};

///// print_viable_tasks_data /////

/**
**/


class cPopulationEventprint_viable_tasks_data : public cPopulationEvent {
private:
  cString filename;
public:
  cPopulationEventprint_viable_tasks_data(const cString & in_args):
  cPopulationEvent("print_viable_tasks_data", in_args) {
    
    cString args(in_args);
    if (args == "") filename="viable_tasks.dat"; else filename=args.PopWord();
  }
  ///// print_viable_tasks_data /////
  void Process(){
    static ofstream datafile(filename());
    cAnalyzeUtil::PrintViableTasksData( population, datafile );
  }
};

///// apocalypse /////

/**
* Randomly removes a certain proportion of the population.
 *
 * Parameters:
 * removal probability (double) default: 0.9
   *   The probability with which a single organism is removed.
   **/


class cPopulationEventapocalypse : public cPopulationEvent {
private:
  double kill_prob;
public:
  cPopulationEventapocalypse(const cString & in_args):
  cPopulationEvent("apocalypse", in_args) {
    
    cString args(in_args);
    if (args == "") kill_prob=.9; else kill_prob=args.PopWord().AsDouble();
  }
  ///// apocalypse /////
  void Process(){
    for (int i = 0; i < population->GetSize(); i++) {
      cPopulationCell & cell = population->GetCell(i);
      if (cell.IsOccupied() == false) continue;
      if (g_random.P(kill_prob))  population->KillOrganism(cell);
    }
  }
};

///// kill_rectangle /////

/**
* Kills all cell in a rectangle.
 *
 * Parameters:
 * cell [X1][Y1][x2][Y2] (integer) default: 0
   *   The start and stoping grid-points into which the organism should
   be killed.
   **/


class cPopulationEventkill_rectangle : public cPopulationEvent {
private:
  int cell_X1;
  int cell_Y1;
  int cell_X2;
  int cell_Y2;
public:
    cPopulationEventkill_rectangle(const cString & in_args):
    cPopulationEvent("kill_rectangle", in_args) {
      
      cString args(in_args);
      if (args == "") cell_X1=0; else cell_X1=args.PopWord().AsInt();
      if (args == "") cell_Y1=0; else cell_Y1=args.PopWord().AsInt();
      if (args == "") cell_X2=0; else cell_X2=args.PopWord().AsInt();
      if (args == "") cell_Y2=0; else cell_Y2=args.PopWord().AsInt();
    }
  ///// kill_rectangle /////
  void Process(){
    int i, j, loc;
    /* Be sure the user entered a valid range */
    if (cell_X1 < 0) {
      cell_X1 = 0;
    } else if (cell_X1 > population->GetWorldX() - 1) {
      cell_X1 = population->GetWorldX() - 1;
    }
    if (cell_X2 < 0) {
      cell_X2 = 0;
    } else if (cell_X2 > population->GetWorldX() - 1) {
      cell_X2 = population->GetWorldX() - 1;
    }
    if (cell_Y1 < 0) {
      cell_Y1 = 0;
    } else if (cell_Y1 > population->GetWorldY() - 1) {
      cell_Y1 = population->GetWorldY() - 1;
    }
    if (cell_Y2 < 0) {
      cell_Y2 = 0;
    } else if (cell_Y2 > population->GetWorldY() - 1) {
      cell_Y2 = population->GetWorldY() - 1;
    }
    /* Account for a rectangle that crosses over the Zero X or Y cell */
    if (cell_X2 < cell_X1) {
      cell_X2 = cell_X2 + population->GetWorldX();
    }
    if (cell_Y2 < cell_Y1) {
      cell_Y2 = cell_Y2 + population->GetWorldY();
    }
    for (i = cell_Y1; i <= cell_Y2; i++) {
      for (j = cell_X1; j <= cell_X2; j++) {
        loc = (i % population->GetWorldY()) * population->GetWorldX() +
        (j % population->GetWorldX());
        cPopulationCell & cell = population->GetCell(loc);
        if (cell.IsOccupied() == true) {
          population->KillOrganism(cell);
        }
      }
    }
    population->SetSyncEvents(true);
  }
};

///// rate_kill /////

/**
* Randomly removes a certain proportion of the population.
 * In principle, this event does the same thing as the apocalypse event.
 * However, instead of a probability, here one has to specify a rate. The
 * rate has the same unit as fitness. So if the average fitness is 20000,
 * then you remove 50% of the population on every update with a removal rate
 * of 10000.
 *
 * Parameters:
 * removal rate (double)
 *   The rate at which organisms are removed.
 **/


class cPopulationEventrate_kill : public cPopulationEvent {
private:
  double kill_rate;
public:
  cPopulationEventrate_kill(const cString & in_args):
  cPopulationEvent("rate_kill", in_args) {
    
    cString args(in_args);
    kill_rate = args.PopWord().AsDouble();
  }
  ///// rate_kill /////
  void Process(){
    double ave_merit = population->GetStats().SumMerit().Average();
    if ( ave_merit <= 0 )
      ave_merit = 1; // make sure that we don't get NAN's or negative numbers
    ave_merit /= cConfig::GetAveTimeslice();
    const double kill_prob = kill_rate / ave_merit;
    for (int i = 0; i < population->GetSize(); i++) {
      cPopulationCell & cell = population->GetCell(i);
      if (cell.IsOccupied() == false) continue;
      if (g_random.P(kill_prob))  population->KillOrganism(cell);
    }
  }
};

///// serial_transfer /////

/**
* This event does again the same thing as apocalypse. However, now
 * the number of organisms to be retained can be specified
 * exactly. Also, it is possible to specify whether any of these
 * organisms may be dead or not.
 *
 * Parameters:
 * transfer size (int) default: 1
   *   The number of organisms to retain. If there are fewer living
   *   organisms than the specified transfer size, then all living
   *   organisms are retained.
   * ignore deads (int) default: 1
     *   When set to 1, only living organisms are retained. Otherwise,
     *   every type of organism can be retained.
     **/


class cPopulationEventserial_transfer : public cPopulationEvent {
private:
  int transfer_size;
  int ignore_deads;
public:
    cPopulationEventserial_transfer(const cString & in_args):
    cPopulationEvent("serial_transfer", in_args) {
      
      cString args(in_args);
      if (args == "") transfer_size=1; else transfer_size=args.PopWord().AsInt();
      if (args == "") ignore_deads=1; else ignore_deads=args.PopWord().AsInt();
    }
  ///// serial_transfer /////
  void Process(){
    population->SerialTransfer( transfer_size, ignore_deads );
  }
};

///// hillclimb /////

/**
* Does a hill climb with the dominant genotype.
 **/


class cPopulationEventhillclimb : public cPopulationEvent {
private:
public:
  cPopulationEventhillclimb(const cString & in_args):
  cPopulationEvent("hillclimb", in_args) {
    (void)in_args; }
  ///// hillclimb /////
  void Process(){
    cGenome & genome = population->GetGenebank().GetBestGenotype()->GetGenome();
    ofstream fp("hillclimb.dat");
    cLandscape landscape(genome, population->GetEnvironment().GetInstSet());
    landscape.HillClimb(fp);
  }
};

///// hillclimb_neut /////

/**
**/


class cPopulationEventhillclimb_neut : public cPopulationEvent {
private:
public:
  cPopulationEventhillclimb_neut(const cString & in_args):
  cPopulationEvent("hillclimb_neut", in_args) {
    (void)in_args; }
  ///// hillclimb_neut /////
  void Process(){
    cGenome & genome = population->GetGenebank().GetBestGenotype()->GetGenome();
    ofstream fp("hillclimb.dat");
    cLandscape landscape(genome, population->GetEnvironment().GetInstSet());
    landscape.HillClimb_Neut(fp);
  }
};

///// hillclimb_rand /////

/**
**/


class cPopulationEventhillclimb_rand : public cPopulationEvent {
private:
public:
  cPopulationEventhillclimb_rand(const cString & in_args):
  cPopulationEvent("hillclimb_rand", in_args) {
    (void)in_args; }
  ///// hillclimb_rand /////
  void Process(){
    cGenome & genome = population->GetGenebank().GetBestGenotype()->GetGenome();
    ofstream fp("hillclimb.dat");
    cLandscape landscape(genome, population->GetEnvironment().GetInstSet());
    landscape.HillClimb_Rand(fp);
  }
};

///// compete_demes /////

/**
* Compete all of the demes using a basic genetic algorithm approach. Fitness
 * of each deme is determined differently depending on the competition_type: 
 * 0: deme fitness = 1 (control, random deme selection)
 * 1: deme fitness = number of births since last competition (default) 
 * 2: deme fitness = average organism fitness at the current update
 * 3: deme fitness = average mutation rate at the current update
 * Merit can optionally be passed in.
 **/


class cPopulationEventcompete_demes : public cPopulationEvent {
private:
  int competition_type;
public:
  cPopulationEventcompete_demes(const cString & in_args):
  cPopulationEvent("compete_demes", in_args) {
    
    cString args(in_args);
    if (args == "") competition_type=1; else competition_type=args.PopWord().AsInt();
  }
  ///// compete_demes /////
  void Process(){
    population->CompeteDemes(competition_type);
  }
};

///// reset_demes /////

/**
* Designed to serve as a control for the compete_demes. Each deme is 
 * copied into itself and the parameters reset. 
 **/


class cPopulationEventreset_demes : public cPopulationEvent {
private:
public:
  cPopulationEventreset_demes(const cString & in_args):
  cPopulationEvent("reset_demes", in_args) {
    (void)in_args; }
  ///// reset_demes /////
  void Process(){
    population->ResetDemes();
  }
};

///// print_deme_stats /////

/**
* Print stats about individual demes
 **/


class cPopulationEventprint_deme_stats : public cPopulationEvent {
private:
public:
  cPopulationEventprint_deme_stats(const cString & in_args):
  cPopulationEvent("print_deme_stats", in_args) {
    (void)in_args; }
  ///// print_deme_stats /////
  void Process(){
    population->PrintDemeStats();
  }
};

///// copy_deme /////

/**
* Takes two numbers as arguments and copies the contents of the first deme
 * listed into the second.
 **/


class cPopulationEventcopy_deme : public cPopulationEvent {
private:
  int deme1_id;
  int deme2_id;
public:
    cPopulationEventcopy_deme(const cString & in_args):
    cPopulationEvent("copy_deme", in_args) {
      
      cString args(in_args);
      deme1_id = args.PopWord().AsInt();
      deme2_id = args.PopWord().AsInt();
    }
  ///// copy_deme /////
  void Process(){
    population->CopyDeme(deme1_id, deme2_id);
  }
};

///// calc_consensus /////

/**
* Calculates the consensus sequence.
 *
 * Parameters:
 * lines saved (integer) default: 0
   *    ???
   **/


class cPopulationEventcalc_consensus : public cPopulationEvent {
private:
  int lines_saved;
public:
  cPopulationEventcalc_consensus(const cString & in_args):
  cPopulationEvent("calc_consensus", in_args) {
    
    cString args(in_args);
    if (args == "") lines_saved=0; else lines_saved=args.PopWord().AsInt();
  }
  ///// calc_consensus /////
  void Process(){
    cAnalyzeUtil::CalcConsensus(population, lines_saved);
  }
};

///// test_size_change_robustness /////

/**
**/


class cPopulationEventtest_size_change_robustness : public cPopulationEvent {
private:
  int num_trials;
  cString filename;
public:
    cPopulationEventtest_size_change_robustness(const cString & in_args):
    cPopulationEvent("test_size_change_robustness", in_args) {
      
      cString args(in_args);
      if (args == "") num_trials=100; else num_trials=args.PopWord().AsInt();
      if (args == "") filename="size_change.dat"; else filename=args.PopWord();
    }
  ///// test_size_change_robustness /////
  void Process(){
    ofstream & fp = population->GetStats().GetDataFileOFStream(filename);
    cAnalyzeUtil::TestInsSizeChangeRobustness(fp,
                                              population->GetEnvironment().GetInstSet(),
                                              population->GetGenebank().GetBestGenotype()->GetGenome(),
                                              num_trials, population->GetUpdate());
  }
};

///// test_threads /////

/**
**/


class cPopulationEventtest_threads : public cPopulationEvent {
private:
public:
  cPopulationEventtest_threads(const cString & in_args):
  cPopulationEvent("test_threads", in_args) {
    (void)in_args; }
  ///// test_threads /////
  void Process(){
    cTestCPU::TestThreads(population->GetGenebank().GetBestGenotype()->GetGenome());
  }
};

///// print_threads /////

/**
**/


class cPopulationEventprint_threads : public cPopulationEvent {
private:
public:
  cPopulationEventprint_threads(const cString & in_args):
  cPopulationEvent("print_threads", in_args) {
    (void)in_args; }
  ///// print_threads /////
  void Process(){
    cTestCPU::PrintThreads( population->GetGenebank().GetBestGenotype()->GetGenome() );
  }
};

///// dump_fitness_grid /////

/**
* Writes out all fitness values of the organisms currently in the
 * population.
 *
 * The output file is called "fgrid.*.out", where '*' is replaced by the
 * number of the current update.
 **/


class cPopulationEventdump_fitness_grid : public cPopulationEvent {
private:
public:
  cPopulationEventdump_fitness_grid(const cString & in_args):
  cPopulationEvent("dump_fitness_grid", in_args) {
    (void)in_args; }
  ///// dump_fitness_grid /////
  void Process(){
    cString filename;
    filename.Set("fgrid.%05d.out", population->GetUpdate());
    ofstream fp(filename());
    for (int i = 0; i < population->GetWorldX(); i++) {
      for (int j = 0; j < population->GetWorldY(); j++) {
        cPopulationCell & cell = population->GetCell(j*population->GetWorldX()+i);
        double fitness = (cell.IsOccupied()) ?
          cell.GetOrganism()->GetGenotype()->GetFitness() : 0.0;
        fp << fitness << " ";
      }
      fp << endl;
    }
  }
};

///// dump_genotype_grid /////

/**
* Writes out all genotype id values of the organisms currently in the
 * population.
 *
 * The output file is called "idgrid.*.out", where '*' is replaced by the
 * number of the current update.
 **/


class cPopulationEventdump_genotype_grid : public cPopulationEvent {
private:
public:
  cPopulationEventdump_genotype_grid(const cString & in_args):
  cPopulationEvent("dump_genotype_grid", in_args) {
    (void)in_args; }
  ///// dump_genotype_grid /////
  void Process(){
    cString filename;
    filename.Set("idgrid.%05d.out", population->GetUpdate());
    ofstream fp(filename());
    for (int i = 0; i < population->GetWorldX(); i++) {
      for (int j = 0; j < population->GetWorldY(); j++) {
        cPopulationCell & cell = population->GetCell(j*population->GetWorldX()+i);
        int id = (cell.IsOccupied()) ?
          cell.GetOrganism()->GetGenotype()->GetID() : -1;
        fp << id << " ";
      }
      fp << endl;
    }
  }
};

///// dump_task_grid /////

/**
* Writes out a grid of tasks done by each organism
 * Tasks are encoded as a binary string first, and then converted into a
 * base 10 number 
 **/


class cPopulationEventdump_task_grid : public cPopulationEvent {
private:
public:
  cPopulationEventdump_task_grid(const cString & in_args):
  cPopulationEvent("dump_task_grid", in_args) {
    (void)in_args; }
  ///// dump_task_grid /////
  void Process(){
    cString filename;
    filename.Set("task_grid_%d.dat",population->GetUpdate());
    ofstream fp(filename());
    cAnalyzeUtil::TaskGrid( population, fp );
  }
};

///// dump_donor_grid /////

/**
* Writes out the grid of donor organisms in the population
 * 
 * The output file is called "donor_grid.*.out", where '*' is replaced by the
 * number of the current update.
 **/   


class cPopulationEventdump_donor_grid : public cPopulationEvent {
private:
public:
  cPopulationEventdump_donor_grid(const cString & in_args):
  cPopulationEvent("dump_donor_grid", in_args) {
    (void)in_args; }
  ///// dump_donor_grid /////
  void Process(){
    cString filename;
    filename.Set("donor_grid.%05d.out", population->GetUpdate());
    ofstream fp(filename());
    for (int i = 0; i < population->GetWorldX(); i++) {  
      for (int j = 0; j < population->GetWorldY(); j++) {
        cPopulationCell & cell = population->GetCell(j*population->GetWorldX()+i);
        int donor = cell.IsOccupied() ?  
          cell.GetOrganism()->GetPhenotype().IsDonorLast() : -1;    
        fp << donor << " ";
      }
      fp << endl;
    }
  }
};

///// dump_receiver_grid /////

/**
* Writes out the grid of organisms which received merit in the population
 *
 * The output file is called "receiver_grid.*.out", where '*' is replaced by the
 * number of the current update.
 **/


class cPopulationEventdump_receiver_grid : public cPopulationEvent {
private:
public:
  cPopulationEventdump_receiver_grid(const cString & in_args):
  cPopulationEvent("dump_receiver_grid", in_args) {
    (void)in_args; }
  ///// dump_receiver_grid /////
  void Process(){
    cString filename;
    filename.Set("receiver_grid.%05d.out", population->GetUpdate());
    ofstream fp(filename());
    for (int i = 0; i < population->GetWorldX(); i++) {
      for (int j = 0; j < population->GetWorldY(); j++) {
        cPopulationCell & cell = population->GetCell(j*population->GetWorldX()+i);
        int receiver = cell.IsOccupied() ?
          cell.GetOrganism()->GetPhenotype().IsReceiver() : -1;
        fp << receiver << " ";
      }
      fp << endl;
    }
  }
};

///// print_tree_depths /////

/**
* Reconstruction of phylogenetic trees.
 **/


class cPopulationEventprint_tree_depths : public cPopulationEvent {
private:
  cString filename;
public:
  cPopulationEventprint_tree_depths(const cString & in_args):
  cPopulationEvent("print_tree_depths", in_args) {
    
    cString args(in_args);
    if (args == "") filename=""; else filename=args.PopWord();
  }
  ///// print_tree_depths /////
  void Process(){
    if (filename == "") filename.Set("tree_depth.%d.dat", population->GetUpdate());
    ofstream fp(filename);
    cAnalyzeUtil::PrintTreeDepths(population, fp);
  }
};

///// sever_grid_col /////

/**
* Remove the connections between cells along a column in an avida grid.
 * Arguments:
 *  col_id:  indicates the number of columns to the left of the cut.
 *           default (or -1) = cut population in half
 *  min_row: First row to start cutting from
 *           default = 0
 *  max_row: Last row to cut to
 *           default (or -1) = last row in population.
 **/


class cPopulationEventsever_grid_col : public cPopulationEvent {
private:
  int col_id;
  int min_row;
  int max_row;
public:
    cPopulationEventsever_grid_col(const cString & in_args):
    cPopulationEvent("sever_grid_col", in_args) {
      
      cString args(in_args);
      if (args == "") col_id=-1; else col_id=args.PopWord().AsInt();
      if (args == "") min_row=0; else min_row=args.PopWord().AsInt();
      if (args == "") max_row=-1; else max_row=args.PopWord().AsInt();
    }
  ///// sever_grid_col /////
  void Process(){
    const int world_x = population->GetWorldX();
    const int world_y = population->GetWorldY();
    if (col_id == -1) col_id = world_x / 2;
    if (max_row == -1) max_row = world_y;
    if (col_id < 0 || col_id >= world_x) {
      cerr << "Event Error: Column ID " << col_id
      << " out of range for sever_grid_col" << endl;
      return;
    }
    // Loop through all of the rows and make the cut on each...
    for (int row_id = min_row; row_id < max_row; row_id++) {
      int idA = row_id * world_x + col_id;
      int idB  = GridNeighbor(idA, world_x, world_y, -1,  0);
      int idA0 = GridNeighbor(idA, world_x, world_y,  0, -1);
      int idA1 = GridNeighbor(idA, world_x, world_y,  0,  1);
      int idB0 = GridNeighbor(idA, world_x, world_y, -1, -1);
      int idB1 = GridNeighbor(idA, world_x, world_y, -1,  1);
      cPopulationCell & cellA = population->GetCell(idA);
      cPopulationCell & cellB = population->GetCell(idB);
      tList<cPopulationCell> & cellA_list = cellA.ConnectionList();
      tList<cPopulationCell> & cellB_list = cellB.ConnectionList();
      cellA_list.Remove(&population->GetCell(idB));
      cellA_list.Remove(&population->GetCell(idB0));
      cellA_list.Remove(&population->GetCell(idB1));
      cellB_list.Remove(&population->GetCell(idA));
      cellB_list.Remove(&population->GetCell(idA0));
      cellB_list.Remove(&population->GetCell(idA1));
    }
  }
};

///// sever_grid_row /////

/**
* Remove the connections between cells along a column in an avida grid.
 * Arguments:
 *  row_id:  indicates the number of rows above the cut.
 *           default (or -1) = cut population in half
 *  min_col: First row to start cutting from
 *           default = 0
 *  max_col: Last row to cut to
 *           default (or -1) = last row in population.
 **/


class cPopulationEventsever_grid_row : public cPopulationEvent {
private:
  int row_id;
  int min_col;
  int max_col;
public:
    cPopulationEventsever_grid_row(const cString & in_args):
    cPopulationEvent("sever_grid_row", in_args) {
      
      cString args(in_args);
      if (args == "") row_id=-1; else row_id=args.PopWord().AsInt();
      if (args == "") min_col=0; else min_col=args.PopWord().AsInt();
      if (args == "") max_col=-1; else max_col=args.PopWord().AsInt();
    }
  ///// sever_grid_row /////
  void Process(){
    const int world_x = population->GetWorldX();
    const int world_y = population->GetWorldY();
    if (row_id == -1) row_id = world_y / 2;
    if (max_col == -1) max_col = world_x;
    if (row_id < 0 || row_id >= world_y) {
      cerr << "Event Error: Row ID " << row_id
      << " out of range for sever_grid_row" << endl;
      return;
    }
    // Loop through all of the cols and make the cut on each...
    for (int col_id = min_col; col_id < max_col; col_id++) {
      int idA = row_id * world_x + col_id;
      int idB  = GridNeighbor(idA, world_x, world_y,  0, -1);
      int idA0 = GridNeighbor(idA, world_x, world_y, -1,  0);
      int idA1 = GridNeighbor(idA, world_x, world_y,  1,  0);
      int idB0 = GridNeighbor(idA, world_x, world_y, -1, -1);
      int idB1 = GridNeighbor(idA, world_x, world_y,  1, -1);
      cPopulationCell & cellA = population->GetCell(idA);
      cPopulationCell & cellB = population->GetCell(idB);
      tList<cPopulationCell> & cellA_list = cellA.ConnectionList();
      tList<cPopulationCell> & cellB_list = cellB.ConnectionList();
      cellA_list.Remove(&population->GetCell(idB));
      cellA_list.Remove(&population->GetCell(idB0));
      cellA_list.Remove(&population->GetCell(idB1));
      cellB_list.Remove(&population->GetCell(idA));
      cellB_list.Remove(&population->GetCell(idA0));
      cellB_list.Remove(&population->GetCell(idA1));
    }
  }
};

///// join_grid_col /////

/**
* Join the connections between cells along a column in an avida grid.
 * Arguments:
 *  col_id:  indicates the number of columns to the left of the joining.
 *           default (or -1) = join population halves.
 *  min_row: First row to start joining from
 *           default = 0
 *  max_row: Last row to join to
 *           default (or -1) = last row in population.
 **/


class cPopulationEventjoin_grid_col : public cPopulationEvent {
private:
  int col_id;
  int min_row;
  int max_row;
public:
    cPopulationEventjoin_grid_col(const cString & in_args):
    cPopulationEvent("join_grid_col", in_args) {
      
      cString args(in_args);
      if (args == "") col_id=-1; else col_id=args.PopWord().AsInt();
      if (args == "") min_row=0; else min_row=args.PopWord().AsInt();
      if (args == "") max_row=-1; else max_row=args.PopWord().AsInt();
    }
  ///// join_grid_col /////
  void Process(){
    const int world_x = population->GetWorldX();
    const int world_y = population->GetWorldY();
    if (col_id == -1) col_id = world_x / 2;
    if (max_row == -1) max_row = world_y;
    if (col_id < 0 || col_id >= world_x) {
      cerr << "Event Error: Column ID " << col_id
      << " out of range for join_grid_col" << endl;
      return;
    }
    // Loop through all of the rows and make the cut on each...
    for (int row_id = min_row; row_id < max_row; row_id++) {
      int idA = row_id * world_x + col_id;
      int idB  = GridNeighbor(idA, world_x, world_y, -1,  0);
      cPopulationCell & cellA = population->GetCell(idA);
      cPopulationCell & cellB = population->GetCell(idB);
      cPopulationCell & cellA0 =
        population->GetCell(GridNeighbor(idA, world_x, world_y,  0, -1));
      cPopulationCell & cellA1 =
        population->GetCell(GridNeighbor(idA, world_x, world_y,  0,  1));
      cPopulationCell & cellB0 =
        population->GetCell(GridNeighbor(idA, world_x, world_y, -1, -1));
      cPopulationCell & cellB1 =
        population->GetCell(GridNeighbor(idA, world_x, world_y, -1,  1));
      tList<cPopulationCell> & cellA_list = cellA.ConnectionList();
      tList<cPopulationCell> & cellB_list = cellB.ConnectionList();
      if (cellA_list.FindPtr(&cellB)  == NULL) cellA_list.Push(&cellB);
      if (cellA_list.FindPtr(&cellB0) == NULL) cellA_list.Push(&cellB0);
      if (cellA_list.FindPtr(&cellB1) == NULL) cellA_list.Push(&cellB1);
      if (cellB_list.FindPtr(&cellA)  == NULL) cellB_list.Push(&cellA);
      if (cellB_list.FindPtr(&cellA0) == NULL) cellB_list.Push(&cellA0);
      if (cellB_list.FindPtr(&cellA1) == NULL) cellB_list.Push(&cellA1);
    }
  }
};

///// join_grid_row /////

/**
* Remove the connections between cells along a column in an avida grid.
 * Arguments:
 *  row_id:  indicates the number of rows abovef the cut.
 *           default (or -1) = cut population in half
 *  min_col: First row to start cutting from
 *           default = 0
 *  max_col: Last row to cut to
 *           default (or -1) = last row in population.
 **/


class cPopulationEventjoin_grid_row : public cPopulationEvent {
private:
  int row_id;
  int min_col;
  int max_col;
public:
    cPopulationEventjoin_grid_row(const cString & in_args):
    cPopulationEvent("join_grid_row", in_args) {
      
      cString args(in_args);
      if (args == "") row_id=-1; else row_id=args.PopWord().AsInt();
      if (args == "") min_col=0; else min_col=args.PopWord().AsInt();
      if (args == "") max_col=-1; else max_col=args.PopWord().AsInt();
    }
  ///// join_grid_row /////
  void Process(){
    const int world_x = population->GetWorldX();
    const int world_y = population->GetWorldY();
    if (row_id == -1) row_id = world_y / 2;
    if (max_col == -1) max_col = world_x;
    if (row_id < 0 || row_id >= world_y) {
      cerr << "Event Error: Row ID " << row_id
      << " out of range for join_grid_row" << endl;
      return;
    }
    // Loop through all of the cols and make the cut on each...
    for (int col_id = min_col; col_id < max_col; col_id++) {
      int idA = row_id * world_x + col_id;
      int idB  = GridNeighbor(idA, world_x, world_y,  0, -1);
      cPopulationCell & cellA = population->GetCell(idA);
      cPopulationCell & cellB = population->GetCell(idB);
      cPopulationCell & cellA0 =
        population->GetCell(GridNeighbor(idA, world_x, world_y, -1,  0));
      cPopulationCell & cellA1 =
        population->GetCell(GridNeighbor(idA, world_x, world_y,  1,  0));
      cPopulationCell & cellB0 =
        population->GetCell(GridNeighbor(idA, world_x, world_y, -1, -1));
      cPopulationCell & cellB1 =
        population->GetCell(GridNeighbor(idA, world_x, world_y,  1, -1));
      tList<cPopulationCell> & cellA_list = cellA.ConnectionList();
      tList<cPopulationCell> & cellB_list = cellB.ConnectionList();
      if (cellA_list.FindPtr(&cellB)  == NULL) cellA_list.Push(&cellB);
      if (cellA_list.FindPtr(&cellB0) == NULL) cellA_list.Push(&cellB0);
      if (cellA_list.FindPtr(&cellB1) == NULL) cellA_list.Push(&cellB1);
      if (cellB_list.FindPtr(&cellA)  == NULL) cellB_list.Push(&cellA);
      if (cellB_list.FindPtr(&cellA0) == NULL) cellB_list.Push(&cellA0);
      if (cellB_list.FindPtr(&cellA1) == NULL) cellB_list.Push(&cellA1);
    }
  }
};

///// connect_cells /////

/**
* Connects a pair of specified cells.
 * Arguments:
 *  cellA_x, cellA_y, cellB_x, cellB_y
 **/


class cPopulationEventconnect_cells : public cPopulationEvent {
private:
  int cellA_x;
  int cellA_y;
  int cellB_x;
  int cellB_y;
public:
    cPopulationEventconnect_cells(const cString & in_args):
    cPopulationEvent("connect_cells", in_args) {
      
      cString args(in_args);
      cellA_x = args.PopWord().AsInt();
      cellA_y = args.PopWord().AsInt();
      cellB_x = args.PopWord().AsInt();
      cellB_y = args.PopWord().AsInt();
    }
  ///// connect_cells /////
  void Process(){
    const int world_x = population->GetWorldX();
    const int world_y = population->GetWorldY();
    if (cellA_x < 0 || cellA_x >= world_x ||
        cellA_y < 0 || cellA_y >= world_y ||
        cellB_x < 0 || cellB_x >= world_x ||
        cellB_y < 0 || cellB_y >= world_y) {
      cerr << "Event 'connect_cells' cell out of range." << endl;
      return;
    }
    int idA = cellA_y * world_x + cellA_x;
    int idB = cellB_y * world_x + cellB_x;
    cPopulationCell & cellA = population->GetCell(idA);
    cPopulationCell & cellB = population->GetCell(idB);
    tList<cPopulationCell> & cellA_list = cellA.ConnectionList();
    tList<cPopulationCell> & cellB_list = cellB.ConnectionList();
    cellA_list.PushRear(&cellB);
    cellB_list.PushRear(&cellA);
  }
};

///// disconnect_cells /////

/**
* Connects a pair of specified cells.
 * Arguments:
 *  cellA_x, cellA_y, cellB_x, cellB_y
 **/


class cPopulationEventdisconnect_cells : public cPopulationEvent {
private:
  int cellA_x;
  int cellA_y;
  int cellB_x;
  int cellB_y;
public:
    cPopulationEventdisconnect_cells(const cString & in_args):
    cPopulationEvent("disconnect_cells", in_args) {
      
      cString args(in_args);
      cellA_x = args.PopWord().AsInt();
      cellA_y = args.PopWord().AsInt();
      cellB_x = args.PopWord().AsInt();
      cellB_y = args.PopWord().AsInt();
    }
  ///// disconnect_cells /////
  void Process(){
    const int world_x = population->GetWorldX();
    const int world_y = population->GetWorldY();
    if (cellA_x < 0 || cellA_x >= world_x ||
        cellA_y < 0 || cellA_y >= world_y ||
        cellB_x < 0 || cellB_x >= world_x ||
        cellB_y < 0 || cellB_y >= world_y) {
      cerr << "Event 'connect_cells' cell out of range." << endl;
      return;
    }
    int idA = cellA_y * world_x + cellA_x;
    int idB = cellB_y * world_x + cellB_x;
    cPopulationCell & cellA = population->GetCell(idA);
    cPopulationCell & cellB = population->GetCell(idB);
    tList<cPopulationCell> & cellA_list = cellA.ConnectionList();
    tList<cPopulationCell> & cellB_list = cellB.ConnectionList();
    cellA_list.Remove(&cellB);
    cellB_list.Remove(&cellA);
  }
};

///// inject_resource /////

/**
* Inject (add) a specified amount of a specified resource.
 **/


class cPopulationEventinject_resource : public cPopulationEvent {
private:
  cString res_name;
  double res_count;
public:
    cPopulationEventinject_resource(const cString & in_args):
    cPopulationEvent("inject_resource", in_args) {
      
      cString args(in_args);
      res_name = args.PopWord();
      res_count = args.PopWord().AsDouble();
    }
  ///// inject_resource /////
  void Process(){
    cResourceLib & res_lib = population->GetEnvironment().GetResourceLib();
    int res_id = res_lib.GetResource(res_name)->GetID();
    population->UpdateResource(res_id, res_count);
  }
};

///// set_resource /////

/**
* Set the resource amount to a specific level
 **/


class cPopulationEventset_resource : public cPopulationEvent {
private:
  cString res_name;
  double res_count;
public:
    cPopulationEventset_resource(const cString & in_args):
    cPopulationEvent("set_resource", in_args) {
      
      cString args(in_args);
      res_name = args.PopWord();
      res_count = args.PopWord().AsDouble();
    }
  ///// set_resource /////
  void Process(){
    cResourceLib & res_lib = population->GetEnvironment().GetResourceLib();
    cResource * found_resource = res_lib.GetResource(res_name);
    if (found_resource != NULL) {
      population->SetResource(found_resource->GetID(), res_count);
    }
  }
};

///// inject_scaled_resource /////

/**
* Inject (add) a specified amount of a specified resource, scaled by
 * the current average merit divided by the average time slice.
 **/


class cPopulationEventinject_scaled_resource : public cPopulationEvent {
private:
  cString res_name;
  double res_count;
public:
    cPopulationEventinject_scaled_resource(const cString & in_args):
    cPopulationEvent("inject_scaled_resource", in_args) {
      
      cString args(in_args);
      res_name = args.PopWord();
      res_count = args.PopWord().AsDouble();
    }
  ///// inject_scaled_resource /////
  void Process(){
    double ave_merit = population->GetStats().SumMerit().Average();
    if ( ave_merit <= 0 )
      ave_merit = 1; // make sure that we don't get NAN's or negative numbers
    ave_merit /= cConfig::GetAveTimeslice();
    cResourceLib & res_lib = population->GetEnvironment().GetResourceLib();
    int res_id = res_lib.GetResource(res_name)->GetID();
    population->UpdateResource(res_id, res_count/ave_merit);
  }
};

///// outflow_scaled_resource /////

/**
* Removes a specified percentage of a specified resource, scaled by
 * the current average merit divided by the average time slice.
 **/


class cPopulationEventoutflow_scaled_resource : public cPopulationEvent {
private:
  cString res_name;
  double res_perc;
public:
    cPopulationEventoutflow_scaled_resource(const cString & in_args):
    cPopulationEvent("outflow_scaled_resource", in_args) {
      
      cString args(in_args);
      res_name = args.PopWord();
      res_perc = args.PopWord().AsDouble();
    }
  ///// outflow_scaled_resource /////
  void Process(){
    double ave_merit = population->GetStats().SumMerit().Average();
    if ( ave_merit <= 0 )
      ave_merit = 1; // make sure that we don't get NAN's or negative numbers
    ave_merit /= cConfig::GetAveTimeslice();
    cResourceLib & res_lib = population->GetEnvironment().GetResourceLib();
    int res_id = res_lib.GetResource(res_name)->GetID();
    double res_level = population->GetResource(res_id);
    // a quick calculation shows that this formula guarantees that
    // the equilibrium level when resource is not used is independent
    // of the average merit
    double scaled_perc = 1/(1+ave_merit*(1-res_perc)/res_perc);
    res_level -= res_level*scaled_perc;
    population->SetResource(res_id, res_level);
  }
};

///// set_reaction_value /////

/**
* Set the value associated with a reaction to a specific level
 **/


class cPopulationEventset_reaction_value : public cPopulationEvent {
private:
  cString reaction_name;
  double reaction_value;
public:
    cPopulationEventset_reaction_value(const cString & in_args):
    cPopulationEvent("set_reaction_value", in_args) {
      
      cString args(in_args);
      reaction_name = args.PopWord();
      reaction_value = args.PopWord().AsDouble();
    }
  ///// set_reaction_value /////
  void Process(){
    population->GetEnvironment().SetReactionValue(reaction_name, reaction_value);
  }
};

///// set_reaction_value_mult /////

/**
* Change the value of the reaction by multiplying it with the imput number
 **/


class cPopulationEventset_reaction_value_mult : public cPopulationEvent {
private:
  cString reaction_name;
  double value_mult;
public:
    cPopulationEventset_reaction_value_mult(const cString & in_args):
    cPopulationEvent("set_reaction_value_mult", in_args) {
      
      cString args(in_args);
      reaction_name = args.PopWord();
      value_mult = args.PopWord().AsDouble();
    }
  ///// set_reaction_value_mult /////
  void Process(){
    population->GetEnvironment().SetReactionValueMult(reaction_name, value_mult);
  }
};


// EventNameToEnum()
int cPopulationEventFactory::EventNameToEnum(const cString & name) const{
  if( name == "" ){
    return cPopulationEventFactory::EVENT_NO_EVENT;
  }else if (name == "exit") {
    return cPopulationEventFactory::EVENT_exit;
  }else if (name == "exit_if_generation_greater_than") {
    return cPopulationEventFactory::EVENT_exit_if_generation_greater_than;
  }else if (name == "exit_if_update_greater_than") {
    return cPopulationEventFactory::EVENT_exit_if_update_greater_than;
  }else if (name == "exit_if_ave_lineage_label_smaller") {
    return cPopulationEventFactory::EVENT_exit_if_ave_lineage_label_smaller;
  }else if (name == "exit_if_ave_lineage_label_larger") {
    return cPopulationEventFactory::EVENT_exit_if_ave_lineage_label_larger;
  }else if (name == "echo") {
    return cPopulationEventFactory::EVENT_echo;
  }else if (name == "print_data") {
    return cPopulationEventFactory::EVENT_print_data;
  }else if (name == "print_average_data") {
    return cPopulationEventFactory::EVENT_print_average_data;
  }else if (name == "print_error_data") {
    return cPopulationEventFactory::EVENT_print_error_data;
  }else if (name == "print_variance_data") {
    return cPopulationEventFactory::EVENT_print_variance_data;
  }else if (name == "print_dominant_data") {
    return cPopulationEventFactory::EVENT_print_dominant_data;
  }else if (name == "print_stats_data") {
    return cPopulationEventFactory::EVENT_print_stats_data;
  }else if (name == "print_count_data") {
    return cPopulationEventFactory::EVENT_print_count_data;
  }else if (name == "print_totals_data") {
    return cPopulationEventFactory::EVENT_print_totals_data;
  }else if (name == "print_tasks_data") {
    return cPopulationEventFactory::EVENT_print_tasks_data;
  }else if (name == "print_tasks_exe_data") {
    return cPopulationEventFactory::EVENT_print_tasks_exe_data;
  }else if (name == "print_resource_data") {
    return cPopulationEventFactory::EVENT_print_resource_data;
  }else if (name == "print_time_data") {
    return cPopulationEventFactory::EVENT_print_time_data;
  }else if (name == "print_mutation_data") {
    return cPopulationEventFactory::EVENT_print_mutation_data;
  }else if (name == "print_mutation_rate_data") {
    return cPopulationEventFactory::EVENT_print_mutation_rate_data;
  }else if (name == "print_divide_mut_data") {
    return cPopulationEventFactory::EVENT_print_divide_mut_data;
  }else if (name == "print_dom_parasite_data") {
    return cPopulationEventFactory::EVENT_print_dom_parasite_data;
  }else if (name == "print_instruction_data") {
    return cPopulationEventFactory::EVENT_print_instruction_data;
  }else if (name == "print_instruction_abundance_histogram") {
    return cPopulationEventFactory::EVENT_print_instruction_abundance_histogram;
  }else if (name == "print_depth_histogram") {
    return cPopulationEventFactory::EVENT_print_depth_histogram;
  }else if (name == "print_genotype_abundance_histogram") {
    return cPopulationEventFactory::EVENT_print_genotype_abundance_histogram;
  }else if (name == "print_species_abundance_histogram") {
    return cPopulationEventFactory::EVENT_print_species_abundance_histogram;
  }else if (name == "print_lineage_totals") {
    return cPopulationEventFactory::EVENT_print_lineage_totals;
  }else if (name == "print_lineage_counts") {
    return cPopulationEventFactory::EVENT_print_lineage_counts;
  }else if (name == "print_dom") {
    return cPopulationEventFactory::EVENT_print_dom;
  }else if (name == "parasite_debug") {
    return cPopulationEventFactory::EVENT_parasite_debug;
  }else if (name == "print_dom_parasite") {
    return cPopulationEventFactory::EVENT_print_dom_parasite;
  }else if (name == "print_genotype_map") {
    return cPopulationEventFactory::EVENT_print_genotype_map;
  }else if (name == "print_number_phenotypes") {
    return cPopulationEventFactory::EVENT_print_number_phenotypes;
  }else if (name == "print_phenotype_status") {
    return cPopulationEventFactory::EVENT_print_phenotype_status;
  }else if (name == "save_population") {
    return cPopulationEventFactory::EVENT_save_population;
  }else if (name == "load_population") {
    return cPopulationEventFactory::EVENT_load_population;
  }else if (name == "save_clone") {
    return cPopulationEventFactory::EVENT_save_clone;
  }else if (name == "load_clone") {
    return cPopulationEventFactory::EVENT_load_clone;
  }else if (name == "load_dump_file") {
    return cPopulationEventFactory::EVENT_load_dump_file;
  }else if (name == "dump_pop") {
    return cPopulationEventFactory::EVENT_dump_pop;
  }else if (name == "print_genotypes") {
    return cPopulationEventFactory::EVENT_print_genotypes;
  }else if (name == "detail_pop") {
    return cPopulationEventFactory::EVENT_detail_pop;
  }else if (name == "detail_sex_pop") {
    return cPopulationEventFactory::EVENT_detail_sex_pop;
  }else if (name == "detail_parasite_pop") {
    return cPopulationEventFactory::EVENT_detail_parasite_pop;
  }else if (name == "dump_historic_pop") {
    return cPopulationEventFactory::EVENT_dump_historic_pop;
  }else if (name == "dump_historic_sex_pop") {
    return cPopulationEventFactory::EVENT_dump_historic_sex_pop;
  }else if (name == "dump_memory") {
    return cPopulationEventFactory::EVENT_dump_memory;
  }else if (name == "inject") {
    return cPopulationEventFactory::EVENT_inject;
  }else if (name == "inject_all") {
    return cPopulationEventFactory::EVENT_inject_all;
  }else if (name == "inject_range") {
    return cPopulationEventFactory::EVENT_inject_range;
  }else if (name == "inject_sequence") {
    return cPopulationEventFactory::EVENT_inject_sequence;
  }else if (name == "inject_random") {
    return cPopulationEventFactory::EVENT_inject_random;
  }else if (name == "inject_range_parasite") {
    return cPopulationEventFactory::EVENT_inject_range_parasite;
  }else if (name == "inject_range_pair") {
    return cPopulationEventFactory::EVENT_inject_range_pair;
  }else if (name == "zero_muts") {
    return cPopulationEventFactory::EVENT_zero_muts;
  }else if (name == "mod_copy_mut") {
    return cPopulationEventFactory::EVENT_mod_copy_mut;
  }else if (name == "mod_div_mut") {
    return cPopulationEventFactory::EVENT_mod_div_mut;
  }else if (name == "set_copy_mut") {
    return cPopulationEventFactory::EVENT_set_copy_mut;
  }else if (name == "mod_point_mut") {
    return cPopulationEventFactory::EVENT_mod_point_mut;
  }else if (name == "set_point_mut") {
    return cPopulationEventFactory::EVENT_set_point_mut;
  }else if (name == "calc_landscape") {
    return cPopulationEventFactory::EVENT_calc_landscape;
  }else if (name == "predict_w_landscape") {
    return cPopulationEventFactory::EVENT_predict_w_landscape;
  }else if (name == "predict_nu_landscape") {
    return cPopulationEventFactory::EVENT_predict_nu_landscape;
  }else if (name == "sample_landscape") {
    return cPopulationEventFactory::EVENT_sample_landscape;
  }else if (name == "random_landscape") {
    return cPopulationEventFactory::EVENT_random_landscape;
  }else if (name == "analyze_landscape") {
    return cPopulationEventFactory::EVENT_analyze_landscape;
  }else if (name == "pairtest_landscape") {
    return cPopulationEventFactory::EVENT_pairtest_landscape;
  }else if (name == "test_dom") {
    return cPopulationEventFactory::EVENT_test_dom;
  }else if (name == "analyze_population") {
    return cPopulationEventFactory::EVENT_analyze_population;
  }else if (name == "print_detailed_fitness_data") {
    return cPopulationEventFactory::EVENT_print_detailed_fitness_data;
  }else if (name == "print_genetic_distance_data") {
    return cPopulationEventFactory::EVENT_print_genetic_distance_data;
  }else if (name == "genetic_distance_pop_dump") {
    return cPopulationEventFactory::EVENT_genetic_distance_pop_dump;
  }else if (name == "task_snapshot") {
    return cPopulationEventFactory::EVENT_task_snapshot;
  }else if (name == "print_viable_tasks_data") {
    return cPopulationEventFactory::EVENT_print_viable_tasks_data;
  }else if (name == "apocalypse") {
    return cPopulationEventFactory::EVENT_apocalypse;
  }else if (name == "kill_rectangle") {
    return cPopulationEventFactory::EVENT_kill_rectangle;
  }else if (name == "rate_kill") {
    return cPopulationEventFactory::EVENT_rate_kill;
  }else if (name == "serial_transfer") {
    return cPopulationEventFactory::EVENT_serial_transfer;
  }else if (name == "hillclimb") {
    return cPopulationEventFactory::EVENT_hillclimb;
  }else if (name == "hillclimb_neut") {
    return cPopulationEventFactory::EVENT_hillclimb_neut;
  }else if (name == "hillclimb_rand") {
    return cPopulationEventFactory::EVENT_hillclimb_rand;
  }else if (name == "compete_demes") {
    return cPopulationEventFactory::EVENT_compete_demes;
  }else if (name == "reset_demes") {
    return cPopulationEventFactory::EVENT_reset_demes;
  }else if (name == "print_deme_stats") {
    return cPopulationEventFactory::EVENT_print_deme_stats;
  }else if (name == "copy_deme") {
    return cPopulationEventFactory::EVENT_copy_deme;
  }else if (name == "calc_consensus") {
    return cPopulationEventFactory::EVENT_calc_consensus;
  }else if (name == "test_size_change_robustness") {
    return cPopulationEventFactory::EVENT_test_size_change_robustness;
  }else if (name == "test_threads") {
    return cPopulationEventFactory::EVENT_test_threads;
  }else if (name == "print_threads") {
    return cPopulationEventFactory::EVENT_print_threads;
  }else if (name == "dump_fitness_grid") {
    return cPopulationEventFactory::EVENT_dump_fitness_grid;
  }else if (name == "dump_genotype_grid") {
    return cPopulationEventFactory::EVENT_dump_genotype_grid;
  }else if (name == "dump_task_grid") {
    return cPopulationEventFactory::EVENT_dump_task_grid;
  }else if (name == "dump_donor_grid") {
    return cPopulationEventFactory::EVENT_dump_donor_grid;
  }else if (name == "dump_receiver_grid") {
    return cPopulationEventFactory::EVENT_dump_receiver_grid;
  }else if (name == "print_tree_depths") {
    return cPopulationEventFactory::EVENT_print_tree_depths;
  }else if (name == "sever_grid_col") {
    return cPopulationEventFactory::EVENT_sever_grid_col;
  }else if (name == "sever_grid_row") {
    return cPopulationEventFactory::EVENT_sever_grid_row;
  }else if (name == "join_grid_col") {
    return cPopulationEventFactory::EVENT_join_grid_col;
  }else if (name == "join_grid_row") {
    return cPopulationEventFactory::EVENT_join_grid_row;
  }else if (name == "connect_cells") {
    return cPopulationEventFactory::EVENT_connect_cells;
  }else if (name == "disconnect_cells") {
    return cPopulationEventFactory::EVENT_disconnect_cells;
  }else if (name == "inject_resource") {
    return cPopulationEventFactory::EVENT_inject_resource;
  }else if (name == "set_resource") {
    return cPopulationEventFactory::EVENT_set_resource;
  }else if (name == "inject_scaled_resource") {
    return cPopulationEventFactory::EVENT_inject_scaled_resource;
  }else if (name == "outflow_scaled_resource") {
    return cPopulationEventFactory::EVENT_outflow_scaled_resource;
  }else if (name == "set_reaction_value") {
    return cPopulationEventFactory::EVENT_set_reaction_value;
  }else if (name == "set_reaction_value_mult") {
    return cPopulationEventFactory::EVENT_set_reaction_value_mult;
  }else{
    return cPopulationEventFactory::EVENT_undefined;
  }
}


/////////////////
// cPopulationEventFactory
/////////////////

cPopulationEventFactory::cPopulationEventFactory( cPopulation *pop ) 
  : m_population( pop )
{
}

cPopulationEventFactory::~cPopulationEventFactory()
{
}

//******* construction of events **********//
cEvent *
cPopulationEventFactory::ConstructEvent( int event_enum,
				    const cString & arg_list )
{
  cPopulationEvent *event = NULL;

  switch (event_enum){

    case cPopulationEventFactory::EVENT_exit :
      event = new cPopulationEventexit(arg_list);
      break;
    case cPopulationEventFactory::EVENT_exit_if_generation_greater_than :
      event = new cPopulationEventexit_if_generation_greater_than(arg_list);
      break;
    case cPopulationEventFactory::EVENT_exit_if_update_greater_than :
      event = new cPopulationEventexit_if_update_greater_than(arg_list);
      break;
    case cPopulationEventFactory::EVENT_exit_if_ave_lineage_label_smaller :
      event = new cPopulationEventexit_if_ave_lineage_label_smaller(arg_list);
      break;
    case cPopulationEventFactory::EVENT_exit_if_ave_lineage_label_larger :
      event = new cPopulationEventexit_if_ave_lineage_label_larger(arg_list);
      break;
    case cPopulationEventFactory::EVENT_echo :
      event = new cPopulationEventecho(arg_list);
      break;
    case cPopulationEventFactory::EVENT_print_data :
      event = new cPopulationEventprint_data(arg_list);
      break;
    case cPopulationEventFactory::EVENT_print_average_data :
      event = new cPopulationEventprint_average_data(arg_list);
      break;
    case cPopulationEventFactory::EVENT_print_error_data :
      event = new cPopulationEventprint_error_data(arg_list);
      break;
    case cPopulationEventFactory::EVENT_print_variance_data :
      event = new cPopulationEventprint_variance_data(arg_list);
      break;
    case cPopulationEventFactory::EVENT_print_dominant_data :
      event = new cPopulationEventprint_dominant_data(arg_list);
      break;
    case cPopulationEventFactory::EVENT_print_stats_data :
      event = new cPopulationEventprint_stats_data(arg_list);
      break;
    case cPopulationEventFactory::EVENT_print_count_data :
      event = new cPopulationEventprint_count_data(arg_list);
      break;
    case cPopulationEventFactory::EVENT_print_totals_data :
      event = new cPopulationEventprint_totals_data(arg_list);
      break;
    case cPopulationEventFactory::EVENT_print_tasks_data :
      event = new cPopulationEventprint_tasks_data(arg_list);
      break;
    case cPopulationEventFactory::EVENT_print_tasks_exe_data :
      event = new cPopulationEventprint_tasks_exe_data(arg_list);
      break;
    case cPopulationEventFactory::EVENT_print_resource_data :
      event = new cPopulationEventprint_resource_data(arg_list);
      break;
    case cPopulationEventFactory::EVENT_print_time_data :
      event = new cPopulationEventprint_time_data(arg_list);
      break;
    case cPopulationEventFactory::EVENT_print_mutation_data :
      event = new cPopulationEventprint_mutation_data(arg_list);
      break;
    case cPopulationEventFactory::EVENT_print_mutation_rate_data :
      event = new cPopulationEventprint_mutation_rate_data(arg_list);
      break;
    case cPopulationEventFactory::EVENT_print_divide_mut_data :
      event = new cPopulationEventprint_divide_mut_data(arg_list);
      break;
    case cPopulationEventFactory::EVENT_print_dom_parasite_data :
      event = new cPopulationEventprint_dom_parasite_data(arg_list);
      break;
    case cPopulationEventFactory::EVENT_print_instruction_data :
      event = new cPopulationEventprint_instruction_data(arg_list);
      break;
    case cPopulationEventFactory::EVENT_print_instruction_abundance_histogram :
      event = new cPopulationEventprint_instruction_abundance_histogram(arg_list);
      break;
    case cPopulationEventFactory::EVENT_print_depth_histogram :
      event = new cPopulationEventprint_depth_histogram(arg_list);
      break;
    case cPopulationEventFactory::EVENT_print_genotype_abundance_histogram :
      event = new cPopulationEventprint_genotype_abundance_histogram(arg_list);
      break;
    case cPopulationEventFactory::EVENT_print_species_abundance_histogram :
      event = new cPopulationEventprint_species_abundance_histogram(arg_list);
      break;
    case cPopulationEventFactory::EVENT_print_lineage_totals :
      event = new cPopulationEventprint_lineage_totals(arg_list);
      break;
    case cPopulationEventFactory::EVENT_print_lineage_counts :
      event = new cPopulationEventprint_lineage_counts(arg_list);
      break;
    case cPopulationEventFactory::EVENT_print_dom :
      event = new cPopulationEventprint_dom(arg_list);
      break;
    case cPopulationEventFactory::EVENT_parasite_debug :
      event = new cPopulationEventparasite_debug(arg_list);
      break;
    case cPopulationEventFactory::EVENT_print_dom_parasite :
      event = new cPopulationEventprint_dom_parasite(arg_list);
      break;
    case cPopulationEventFactory::EVENT_print_genotype_map :
      event = new cPopulationEventprint_genotype_map(arg_list);
      break;
    case cPopulationEventFactory::EVENT_print_number_phenotypes :
      event = new cPopulationEventprint_number_phenotypes(arg_list);
      break;
    case cPopulationEventFactory::EVENT_print_phenotype_status :
      event = new cPopulationEventprint_phenotype_status(arg_list);
      break;
    case cPopulationEventFactory::EVENT_save_population :
      event = new cPopulationEventsave_population(arg_list);
      break;
    case cPopulationEventFactory::EVENT_load_population :
      event = new cPopulationEventload_population(arg_list);
      break;
    case cPopulationEventFactory::EVENT_save_clone :
      event = new cPopulationEventsave_clone(arg_list);
      break;
    case cPopulationEventFactory::EVENT_load_clone :
      event = new cPopulationEventload_clone(arg_list);
      break;
    case cPopulationEventFactory::EVENT_load_dump_file :
      event = new cPopulationEventload_dump_file(arg_list);
      break;
    case cPopulationEventFactory::EVENT_dump_pop :
      event = new cPopulationEventdump_pop(arg_list);
      break;
    case cPopulationEventFactory::EVENT_print_genotypes :
      event = new cPopulationEventprint_genotypes(arg_list);
      break;
    case cPopulationEventFactory::EVENT_detail_pop :
      event = new cPopulationEventdetail_pop(arg_list);
      break;
    case cPopulationEventFactory::EVENT_detail_sex_pop :
      event = new cPopulationEventdetail_sex_pop(arg_list);
      break;
    case cPopulationEventFactory::EVENT_detail_parasite_pop :
      event = new cPopulationEventdetail_parasite_pop(arg_list);
      break;
    case cPopulationEventFactory::EVENT_dump_historic_pop :
      event = new cPopulationEventdump_historic_pop(arg_list);
      break;
    case cPopulationEventFactory::EVENT_dump_historic_sex_pop :
      event = new cPopulationEventdump_historic_sex_pop(arg_list);
      break;
    case cPopulationEventFactory::EVENT_dump_memory :
      event = new cPopulationEventdump_memory(arg_list);
      break;
    case cPopulationEventFactory::EVENT_inject :
      event = new cPopulationEventinject(arg_list);
      break;
    case cPopulationEventFactory::EVENT_inject_all :
      event = new cPopulationEventinject_all(arg_list);
      break;
    case cPopulationEventFactory::EVENT_inject_range :
      event = new cPopulationEventinject_range(arg_list);
      break;
    case cPopulationEventFactory::EVENT_inject_sequence :
      event = new cPopulationEventinject_sequence(arg_list);
      break;
    case cPopulationEventFactory::EVENT_inject_random :
      event = new cPopulationEventinject_random(arg_list);
      break;
    case cPopulationEventFactory::EVENT_inject_range_parasite :
      event = new cPopulationEventinject_range_parasite(arg_list);
      break;
    case cPopulationEventFactory::EVENT_inject_range_pair :
      event = new cPopulationEventinject_range_pair(arg_list);
      break;
    case cPopulationEventFactory::EVENT_zero_muts :
      event = new cPopulationEventzero_muts(arg_list);
      break;
    case cPopulationEventFactory::EVENT_mod_copy_mut :
      event = new cPopulationEventmod_copy_mut(arg_list);
      break;
    case cPopulationEventFactory::EVENT_mod_div_mut :
      event = new cPopulationEventmod_div_mut(arg_list);
      break;
    case cPopulationEventFactory::EVENT_set_copy_mut :
      event = new cPopulationEventset_copy_mut(arg_list);
      break;
    case cPopulationEventFactory::EVENT_mod_point_mut :
      event = new cPopulationEventmod_point_mut(arg_list);
      break;
    case cPopulationEventFactory::EVENT_set_point_mut :
      event = new cPopulationEventset_point_mut(arg_list);
      break;
    case cPopulationEventFactory::EVENT_calc_landscape :
      event = new cPopulationEventcalc_landscape(arg_list);
      break;
    case cPopulationEventFactory::EVENT_predict_w_landscape :
      event = new cPopulationEventpredict_w_landscape(arg_list);
      break;
    case cPopulationEventFactory::EVENT_predict_nu_landscape :
      event = new cPopulationEventpredict_nu_landscape(arg_list);
      break;
    case cPopulationEventFactory::EVENT_sample_landscape :
      event = new cPopulationEventsample_landscape(arg_list);
      break;
    case cPopulationEventFactory::EVENT_random_landscape :
      event = new cPopulationEventrandom_landscape(arg_list);
      break;
    case cPopulationEventFactory::EVENT_analyze_landscape :
      event = new cPopulationEventanalyze_landscape(arg_list);
      break;
    case cPopulationEventFactory::EVENT_pairtest_landscape :
      event = new cPopulationEventpairtest_landscape(arg_list);
      break;
    case cPopulationEventFactory::EVENT_test_dom :
      event = new cPopulationEventtest_dom(arg_list);
      break;
    case cPopulationEventFactory::EVENT_analyze_population :
      event = new cPopulationEventanalyze_population(arg_list);
      break;
    case cPopulationEventFactory::EVENT_print_detailed_fitness_data :
      event = new cPopulationEventprint_detailed_fitness_data(arg_list);
      break;
    case cPopulationEventFactory::EVENT_print_genetic_distance_data :
      event = new cPopulationEventprint_genetic_distance_data(arg_list);
      break;
    case cPopulationEventFactory::EVENT_genetic_distance_pop_dump :
      event = new cPopulationEventgenetic_distance_pop_dump(arg_list);
      break;
    case cPopulationEventFactory::EVENT_task_snapshot :
      event = new cPopulationEventtask_snapshot(arg_list);
      break;
    case cPopulationEventFactory::EVENT_print_viable_tasks_data :
      event = new cPopulationEventprint_viable_tasks_data(arg_list);
      break;
    case cPopulationEventFactory::EVENT_apocalypse :
      event = new cPopulationEventapocalypse(arg_list);
      break;
    case cPopulationEventFactory::EVENT_kill_rectangle :
      event = new cPopulationEventkill_rectangle(arg_list);
      break;
    case cPopulationEventFactory::EVENT_rate_kill :
      event = new cPopulationEventrate_kill(arg_list);
      break;
    case cPopulationEventFactory::EVENT_serial_transfer :
      event = new cPopulationEventserial_transfer(arg_list);
      break;
    case cPopulationEventFactory::EVENT_hillclimb :
      event = new cPopulationEventhillclimb(arg_list);
      break;
    case cPopulationEventFactory::EVENT_hillclimb_neut :
      event = new cPopulationEventhillclimb_neut(arg_list);
      break;
    case cPopulationEventFactory::EVENT_hillclimb_rand :
      event = new cPopulationEventhillclimb_rand(arg_list);
      break;
    case cPopulationEventFactory::EVENT_compete_demes :
      event = new cPopulationEventcompete_demes(arg_list);
      break;
    case cPopulationEventFactory::EVENT_reset_demes :
      event = new cPopulationEventreset_demes(arg_list);
      break;
    case cPopulationEventFactory::EVENT_print_deme_stats :
      event = new cPopulationEventprint_deme_stats(arg_list);
      break;
    case cPopulationEventFactory::EVENT_copy_deme :
      event = new cPopulationEventcopy_deme(arg_list);
      break;
    case cPopulationEventFactory::EVENT_calc_consensus :
      event = new cPopulationEventcalc_consensus(arg_list);
      break;
    case cPopulationEventFactory::EVENT_test_size_change_robustness :
      event = new cPopulationEventtest_size_change_robustness(arg_list);
      break;
    case cPopulationEventFactory::EVENT_test_threads :
      event = new cPopulationEventtest_threads(arg_list);
      break;
    case cPopulationEventFactory::EVENT_print_threads :
      event = new cPopulationEventprint_threads(arg_list);
      break;
    case cPopulationEventFactory::EVENT_dump_fitness_grid :
      event = new cPopulationEventdump_fitness_grid(arg_list);
      break;
    case cPopulationEventFactory::EVENT_dump_genotype_grid :
      event = new cPopulationEventdump_genotype_grid(arg_list);
      break;
    case cPopulationEventFactory::EVENT_dump_task_grid :
      event = new cPopulationEventdump_task_grid(arg_list);
      break;
    case cPopulationEventFactory::EVENT_dump_donor_grid :
      event = new cPopulationEventdump_donor_grid(arg_list);
      break;
    case cPopulationEventFactory::EVENT_dump_receiver_grid :
      event = new cPopulationEventdump_receiver_grid(arg_list);
      break;
    case cPopulationEventFactory::EVENT_print_tree_depths :
      event = new cPopulationEventprint_tree_depths(arg_list);
      break;
    case cPopulationEventFactory::EVENT_sever_grid_col :
      event = new cPopulationEventsever_grid_col(arg_list);
      break;
    case cPopulationEventFactory::EVENT_sever_grid_row :
      event = new cPopulationEventsever_grid_row(arg_list);
      break;
    case cPopulationEventFactory::EVENT_join_grid_col :
      event = new cPopulationEventjoin_grid_col(arg_list);
      break;
    case cPopulationEventFactory::EVENT_join_grid_row :
      event = new cPopulationEventjoin_grid_row(arg_list);
      break;
    case cPopulationEventFactory::EVENT_connect_cells :
      event = new cPopulationEventconnect_cells(arg_list);
      break;
    case cPopulationEventFactory::EVENT_disconnect_cells :
      event = new cPopulationEventdisconnect_cells(arg_list);
      break;
    case cPopulationEventFactory::EVENT_inject_resource :
      event = new cPopulationEventinject_resource(arg_list);
      break;
    case cPopulationEventFactory::EVENT_set_resource :
      event = new cPopulationEventset_resource(arg_list);
      break;
    case cPopulationEventFactory::EVENT_inject_scaled_resource :
      event = new cPopulationEventinject_scaled_resource(arg_list);
      break;
    case cPopulationEventFactory::EVENT_outflow_scaled_resource :
      event = new cPopulationEventoutflow_scaled_resource(arg_list);
      break;
    case cPopulationEventFactory::EVENT_set_reaction_value :
      event = new cPopulationEventset_reaction_value(arg_list);
      break;
    case cPopulationEventFactory::EVENT_set_reaction_value_mult :
      event = new cPopulationEventset_reaction_value_mult(arg_list);
      break;
      
    default:
      event = NULL;
      break;
  }

  if( event != NULL ){
    // Have to setup the base class variables
    event->SetFactoryId( GetFactoryId() );

    assert( m_population != NULL );
    event->SetPopulation( m_population );
  }
  return event;
}




