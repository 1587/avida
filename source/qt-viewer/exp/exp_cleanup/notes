
user_msg_ctrl error conditions:
- avdUserMsgCtrl()
  - new avdUserMsgView() returns null
  - new avdUserMsgDply() returns null
- ~avdUserMsgCtrl()
  - none
- setup()
  - getView() returns null
- showUserMsgGUISlot()
  - getView() returns null

analyzer/avd_n_analyzer_ctrl.cc
dumb_gui/avd_dumb_gui.cc
exp_gui/avd_exp_ctrl.cc
map_gui/avd_map_ctrl.cc
menubar/avd_menubar_handler.cc
preferences/avd_prefs_ctrl.cc
threaded_driver/avd_orig_driver_controller.cc
user_msg/avd_user_msg_ctrl.cc
analyzer_o/avd_analyzer_controller.cc

***

Error-handling improvements:
- main XX
- user_msg
  - avd_message_display.cc XX
  - avd_message_display.hh XX
  - avd_message_display_proto.hh XX
  - avd_message_display_typetrack.hh XX
  - avd_message_display_typetrack_proto.hh XX
  - avd_qstr_message_display.cc XX
  - avd_user_msg_ctrl.cc
  - avd_user_msg_ctrl.hh
  - avd_user_msg_ctrl_funct.hh
  - avd_user_msg_ctrl_funct_proto.hh
  - avd_user_msg_gui.cc
  - avd_user_msg_gui_dbg.hh
  - avd_user_msg_gui_dbg_proto.hh
  - avd_user_msg_prefs_ctrl.cc
  - avd_user_msg_prefs_ctrl.hh
  - avd_user_msg_prefs_gui.cc
  - avd_user_msg_prefs_view.cc
  - avd_user_msg_prefs_view.hh
  - avd_user_msg_view.cc
  - avd_user_msg_view.hh
  - gui_message_display.cc
- memory_mgt
- containers
- mc
- threaded_driver
- gui_factory
- menubar
- dumb_gui
- exp_gui
- prefs_gui_factory
- preferences
- map_gui
- analyzer
- analyzer_o

***

speciesid: genotype->GetSpecies()->GetID()
fitness: phenotype->GetFitness()
gestation_time: phenotype->GetGestationTime()
CPU Speed: phenotype->GetMerit()
cur_merit:
  cMerit(phenotype.GetCurBonus()).GetDouble()
Genome Size: genotype ? genotype->GetLength() : 0
mem size: hardware.GetMemory().GetSize()

Facing:
  id = cell->ConnectionList().GetFirst()->GetID()...

Generation: phen.GetGeneration()
Age: phen.GetAge()
Executed: phen.GetTimeUsed()
LastDivide: phen.GetGestationStart()
Offspring: phen.GetNumDivides()

***

there may be many many tasks;
use a mechanism similar to stacks display to show lots of them in the
widget.  each line must be an editable field.

***

Leak-tracking.
  Requires new message tracking sys.
    Requires Loki **
New Zoom data.
New Stats data.

***

Component Zoom is prepped in cZoomScreen::DrawCPU_Original()

cZoomScreen::DrawCPU_Original() is called by cZoomScreen::Draw()

***

Aspects of a map layer:
- from-to color pair
- rgba vs. hsva
  - for hsva, clockwise vs. counterclockwise
- log vs. linear scaling
- endpoints: max/min vs. auto
  - for auto, hysteresis

***

- Basic map layer
  - takes canvas, cPopulation as params
  - original cellviewer stores cPopulationCell pointers
- Basic canvasItem
  - model after old MapViewCellEntry
- Basic retainable canvasView

***

I have no idea how to implement toroidal world wrapping.  Possibilities
include
- moving all QCanvasItems, and wrapping when they fall off of the edge.
- Overdrawing everything (four times, once for each quadrant) and
  reorienting QCanvasViews.
  - This requires some hacks on the QScrollView part of the QCanvasViews
    to make the apparent viewport have 1/2 dimensions of actual
    viewport.
    - Don't know how I'll go about that if I try it.

Can't think of a good way to use one canvase as the background of
another, other than to draw the first canvas to a pixmap, then use that
pixmap as the background for the other.

What needs for Map Items?
- Enough info to know whether color update is needed
  - Might as well update whenever cell id organism is modified
- To store or not store associated cell id / organism ?

Map layer properties:
- What kind of color transition to use
- Coloring function
- Opacity
- Map layer position
- Visibility
- Name
- Color Scales


- Map zoom
- Map center
- Panning widget?

- Associate cell viewer with particular map?

***

Need a QCanvas, QCanvasView per map.

Need to be able to set map controller's population pointer.

The old map viewer had access to cPopulation and selected cell id (int).
It seems access to cPopulation should be enough to draw and update the
map.
- cPopulation can be got using cPopulationInterface::GetPopulation(),
  and the threaded driver ctrl has accessor
  avdAvidaThreadCtrl::getPopulationInterface().
- Looks like I should not use cPopulationInterface::GetCellID(), but
  instead use a sep. cell-id tracking var in the GUI.

***

new stable and unstable branches.
regular testing across all three platforms.
notify evan so he can link new releases into home page. 
a list of stable features in the main branch.
regular stable releases.

***

Q:  how do I know which cols are already displayed?  why do I have both
of col. names and m_data_entry_cmd_list?

***

retainable versions of:
- avdAnalyzerDataEntryBase,
  - avdAnalyzerDataEntry
  - avdAnalyzerArgDataEntry
- avdAnalyzerDataEntryCommand,
- cAnalyzeGenotype,
- NOT cGenotypeBatch, 

Plan for analyzer:
- add m_batch_id_ctr [this is incremented every time a new batch is
  loaded]
- loadHistoricGenotypesSlot()

***

The problem:
  settings data is required at multiple places, but manipulated in one
  place.  How to get only the altered settings, rather than reading them
  all from disk when a single setting changes?

  !!! use functors to broadcast changes!
  * works well.  <whew.>

***

Settings propogation options
- could write to and read from disk, and emit "settingsChangedSig" or
  "FooSettingsChangedSig".
  - advantage:  this goes far in decoupling.
  - 
- could write an "avdFooSettings" singleton class.  Ugly.  I don't like
  so many statics.
- could just write an "avdFooSettings" class.

This is pointless.  Just use the first option via QSettings.  This
paradigm requires that prefs guis be created last.

- could also set a whole bunch of mediator signals.  Place settings code
  only in the prefs sections.  This means that the prefs guis have to be
  created early.  It also means that other gui elements must request
  prefs via the mediator system.
  - advantage: compile-time errors.
  - disadvantage: lots of extra coding.  

***

Suggestions from Elizabeth:
- Problems with genotypes view:  you can't even see the dominant
  organism!
- General defaults unreasonable
  - overhigh mutation rates
  - environment file has rewards factored as powers
  - birth method set.
- viewer doesn't give numbers of updates
- plots:
  - osx lacks plot axis labels
  - plots lose data when all plot windows are closed
  - windows labels have update problems

***

- Another rewrite of the driver,
  - 
- rewrite of connections to and from mission control,
  - split-out pieces.  (what pieces?)
    - currently does...:
      - triggers gui factory in response to menu commands
      - owns and starts the driver
      - starts the initial gui element
      - serves as a message-center
      - owns the mutex, and provides locking services.
      - currently directly handles creation of old gui elements

  - I could provide each gui with driver references, and mutex
    references.
  - or maybe remove information about the driver... Just connect signals
    from the driver to signals in the gui,
    and provide a reference to a limited interface to the driver:
    - just the cAvidaDriver_Population aspect?
      - no.  also add:
        - accessors to
          - cPopulation *population,
          - cEventFactoryManager *event_manager
          - cEventList *event_list
          - QMutex *m_mutex
    - I still need a way for guis to communicate with each other...
      - one way is to create connections for them, so they never know
        who is connected to them.  The disadvantage is requirement that
        all available signals be connected.
      - the second is to provide the same mechanism as before, i.e., a
        messaging center to which they can connect any way that they
        want.

    - summary:
      - provide reference to driver using limited interface (accessors
        only):
        - cPopulation *population,
        - cEventFactoryManager *event_manager
        - cEventList *event_list
        - QMutex *m_mutex
      - provide a cGUIMediator class to handle communication using
        signals:
          changeAvidaState
          avidaStateChanged

***

Idea: For reach QMainWindow, pass its QMenuBar to a menu initialization
object.
- But do that later.

Step: See how to enter analyze mode.  Make a dumb controller.

MissionControl:
- calls avd_GUIFactory::Instance().CreateObject("<key>");

so:
- Menu->MenuItemForGUIPart
  - Triggers a signal
    - Somebody catches the signal
      - Tells MissionControl to create

***

Q: How can I recycle the interactive mode of Analyze mode?
- Observation:  There are as yet no Flow commands required.
- I can keep a list of in-use and available cGenotypeBatches. 

- I can test by entering interactive mode at the console, and then
  "updating" via a button.

How do I load a batch?
- interface to commands 
  - LOAD_ORGANISM [filename]
  - LOAD_BASE_DUMP [filename]
  - LOAD_DETAIL_DUMP [filename]
  - LOAD_SEQUENCE [sequence]

Where is batch name stored?
- cString name at line 349 of analyze.hh.

Where/when are batches named?
- initially (i.e., in cAnalyze::cAnalyze) each batch i is named
  "Batchi".

Try to load and display a batch.
- Each batch corresponds to an entry in the left-hand column.

***

Re:  Local menus handled by the GUI Factory singleton:
- I can use chained functors to make connections to the local controller
  object;
- I can reuse the following snippet to connect to the Factory singleton:
    avd_AbstractGUIController *gc =
      avd_GUIFactory::Instance().CreateObject(controller_type);
    if(m_menubar_handler && gc){
      m_menubar_handler->setupMenuBar(gc->menuBar());
      gc->wrapupInit();
    }
- The local controller must register the functor chain in its
  constructor,
- and it must unregister the functor chain in its destructor.
- the batchviewer and the attribute selector should both be singleton
  windows, maybe selectable using a Windows menu?

***

- Must store list of selected attributes
- Must keep list in sync with view
  - on adding to view, also add to list
  - on deleting from view, also delete from list
    - how to delete?  delete key?  how to detect?
  - on creating view, load items from list

- column corresponding to fmt
- quick way of checking to see whether something exists before adding
  it?

- or just clear, and redraw?

---

Display of properties
- sortable
- headers movable
- order or headers is independant of sort order
  - determined by order of storage in analyze class
  - addition of new fields to display causes them to be added at end.
Q: what happens when you add a field?
Q: when headers are moved, and the field indices are reordered, how do I
know which columns should hold which field-data?

Order of construction:
- able to select fields to display.
  - must also be able to add/remove fields.
    - must keep track of col/field relationship.
  - for now, when the field list changes, redraw the whole table.

needs: translation from field to column
...

***

Better ways of opening each of the viewers?
- map
- instruction
- event editor
- godbox
- plots
- help
- settings

***
***
arch-tag: avida gui development notes to myself.
