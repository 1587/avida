import os
import os.path
import shutil
import sys
import tempfile


class TailChecker:
  """
  Class that uses Avida and an Avida configuration to produce a set of
  last lines of Avida output files, and then compares them to a set of
  corresponding expected last lines that were generated by the companion
  class TailGenerator.
  """
  def __init__(self,
    seed_set,
    run_subdir_path_base,
    output_file_name,
    expectation_file_path_base,
    expectation_file_name,
    avida_exe_path,
    avida_args
  ):
    self.seed_set = seed_set
    self.run_subdir_path_base = run_subdir_path_base
    self.output_file_name = output_file_name
    self.expectation_file_path_base = expectation_file_path_base
    self.expectation_file_name = expectation_file_name
    self.avida_exe_path = avida_exe_path
    self.avida_args = avida_args

    self.failures_dict = {}

  def _check_tail(self, seed):
    run_subdir = self.run_subdir_path_base + str(seed)
    expectation_file_path = self.expectation_file_path_base + str(seed) + '/' + self.expectation_file_name
    avida_command = self.avida_exe_path + ' ' + self.avida_args % {'Seed': str(seed), 'DataDir': run_subdir}

    old_cwd = os.getcwd()

    os.system(avida_command)

    detail_fd = file(os.path.join(run_subdir, self.output_file_name),"rU") 
    next_detail_line = detail_fd.readline()
    while next_detail_line != "":
      last_detail_line = next_detail_line
      next_detail_line = detail_fd.readline()
    detail_fd.close()

    print "last line of output file \"" + self.output_file_name + "\" : "
    print last_detail_line
    
    expected_last_line_fd = file(expectation_file_path, "rU")
    expected_last_detail_line = expected_last_line_fd.readline()
    expected_last_line_fd.close()

    if last_detail_line != expected_last_detail_line:
      print "last line of output file doesn't match expected last line."
      self.failures_dict[seed] = (last_detail_line, expected_last_detail_line)
    else:
      print "last line of output file matches expected last line."

  def check_tails(self):
    for seed in self.seed_set:
      print 'trying seed', seed, 'of seed_set', self.seed_set
      self._check_tail(seed)


class TailGenerator:
  """
  Class that uses Avida to generate a set of expected last lines of output
  files for a particular Avida configuration.
  
  The companion class TailChecker can subsequently use Avida with the same
  configuration to generate a set of actual last lines of corresponding
  output files, compare them to the expected last lines, and report the
  result.
  """
  def __init__(self,
    seed_set,
    run_subdir_path_base,
    genesis_file_path,
    output_file_name,
    expectation_file_path_base,
    expectation_file_name,
    avida_exe_path,
    avida_args
  ):
    self.seed_set = seed_set
    self.run_subdir_path_base = run_subdir_path_base
    self.genesis_file_path = genesis_file_path
    self.output_file_name = output_file_name
    self.expectation_file_path_base = expectation_file_path_base
    self.expectation_file_name = expectation_file_name
    self.avida_exe_path = avida_exe_path
    self.avida_args = avida_args

  def _generate_tail(self, seed):
    run_subdir = self.run_subdir_path_base + str(seed)
    expectation_file_path = self.expectation_file_path_base + str(seed) + '/' + self.expectation_file_name
    avida_command = self.avida_exe_path + ' ' + self.avida_args % seed

    old_cwd = os.getcwd()

    print "from run_subdir " + run_subdir + " : using command : " + avida_command + " :"

    shutil.rmtree(run_subdir, True)
    try:
      os.makedirs(run_subdir)
    except OSError:
      pass
    shutil.copy(self.genesis_file_path, run_subdir)
    os.chdir(run_subdir)
    avida_output_fd = os.popen(avida_command)
    line = avida_output_fd.readline()
    while line != "":
      print line,
      line = avida_output_fd.readline()
    avida_output_fd.close()

    detail_fd = file(self.output_file_name,"rU") 
    next_detail_line = detail_fd.readline()
    while next_detail_line != "":
      last_detail_line = next_detail_line
      next_detail_line = detail_fd.readline()
    detail_fd.close()

    print "last line of output file \"" + self.output_file_name + "\" : "
    print last_detail_line
    
    expected_last_line_fd = file(expectation_file_path, "wU")
    expected_last_line_fd.write(last_detail_line)
    expected_last_line_fd.close()

    os.chdir(old_cwd)

  def generate_tails(self):
    for seed in self.seed_set:
      self._generate_tail(seed)

Import('environment')
e = environment

Import('avida_exe')

TestsName = 'Default-CPU'
ConfigDir = e.Dir('$execPrefix')
GenesisFile = e.File('avida.cfg', ConfigDir)
InstSetFile = e.File('inst_set.default', ConfigDir)
EnvironmentFile = e.File('environment.cfg', ConfigDir)
StartCreatureFile = e.File('organism.default', ConfigDir)

AvidaArgs = "-c %(GenesisFile)s -seed %(Seed)s -set WORLD_X 40 -set WORLD_Y 40 -set INST_SET %(InstSetFile)s -set EVENT_FILE %(EventsFile)s -set ENVIRONMENT_FILE %(EnvironmentFile)s -set START_CREATURE %(StartCreatureFile)s -set DATA_DIR %(DataDir)s" % {
  'Seed':'%(Seed)s',
  'DataDir':'%(DataDir)s',
  'EventsFile':'%(EventsFile)s',
  'GenesisFile':GenesisFile.path,
  'InstSetFile':InstSetFile.path,
  'EnvironmentFile':EnvironmentFile.path,
  'StartCreatureFile':StartCreatureFile.path,
}

RunLength = '500'
TestDirBase = e.Dir('Seed_')
SeedSet = range(100,105)
OutputFileBase = 'detail_pop'
OutputFileName = '%s.%s' % (OutputFileBase, RunLength)
ExpectationFileName = '%s.expected_last_line' % OutputFileName
ExpectationFilePathBase = TestDirBase.srcnode().path
DataDirBase = TestDirBase.path

def tail_checker_action(target, source, env):
  events_file = tempfile.mkstemp('.cfg', 'events.')
  os.write(events_file[0],
'''
u %(RunLength)s:%(RunLength)s detail_pop detail_pop.%(RunLength)s   # Save current state of population.
u %(RunLength)s exit   # exit.
''' % {'RunLength': RunLength}
  )
  os.close(events_file[0])
  tail_checker = TailChecker(
    seed_set = SeedSet,
    run_subdir_path_base = DataDirBase,
    output_file_name = OutputFileName,
    expectation_file_path_base = ExpectationFilePathBase,
    expectation_file_name = ExpectationFileName,
    avida_exe_path = avida_exe[0].path,
    avida_args = AvidaArgs % {'Seed':'%(Seed)s', 'DataDir':'%(DataDir)s', 'EventsFile':events_file[1]}
  )
  try:
    tail_checker.check_tails()
  finally:
    os.remove(events_file[1])

  for seed, lines in tail_checker.failures_dict.iteritems():
    print 'Seed', seed, 'produced unexpected last line in file', output_file_name, ':'
    print lines[0], 'Expected last line in file', expectation_file_name, ':'
    print lines[1]

  if 0 is not len(tail_checker.failures_dict):
    return 1

e.AlwaysBuild(e.Alias('Consistency-Check--%s' % TestsName, [avida_exe], tail_checker_action))

# vim: set ft=python:
